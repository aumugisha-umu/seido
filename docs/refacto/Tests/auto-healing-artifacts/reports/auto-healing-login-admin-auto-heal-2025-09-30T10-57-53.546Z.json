{
  "testName": "login-admin-auto-heal",
  "resolved": false,
  "cycles": [
    {
      "cycleNumber": 1,
      "startTime": "2025-09-30T10:57:14.473Z",
      "endTime": "2025-09-30T10:57:17.495Z",
      "duration": 3022,
      "errorContext": {
        "testId": "auto-heal-login-1759229818815",
        "testName": "login-admin-auto-heal",
        "userRole": "admin",
        "error": {
          "type": "redirect",
          "message": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================",
          "stack": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================\n    at C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing\\demo-login-test.spec.ts:62:22",
          "step": "waitForURL",
          "timestamp": "2025-09-30T10:57:14.470Z"
        },
        "state": {
          "url": "http://localhost:3000/auth/login",
          "expectedUrl": "/admin/dashboard",
          "screenshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png",
          "domSnapshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\dom-snapshot.html",
          "networkLogs": [],
          "consoleLogs": []
        },
        "sourceFiles": [
          {
            "path": "app/actions/auth-actions.ts",
            "content": "/**\r\n * üöÄ SERVER ACTIONS - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Server Actions :\r\n * - Authentification server-side s√©curis√©e\r\n * - Validation c√¥t√© serveur syst√©matique\r\n * - Gestion erreurs appropri√©e\r\n * - Redirections s√©curis√©es avec redirect()\r\n */\r\n\r\n'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { requireGuest, invalidateAuth, getDashboardPath } from '@/lib/auth-dal'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport { z } from 'zod'\r\n\r\n// ‚úÖ VALIDATION: Schemas Zod pour s√©curit√© server-side\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string().min(1, 'Mot de passe requis')\r\n})\r\n\r\nconst SignupSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string()\r\n    .min(8, 'Au moins 8 caract√®res')\r\n    .regex(/[A-Z]/, 'Une majuscule requise')\r\n    .regex(/[a-z]/, 'Une minuscule requise')\r\n    .regex(/\\d/, 'Un chiffre requis'),\r\n  firstName: z.string().min(1, 'Pr√©nom requis').trim(),\r\n  lastName: z.string().min(1, 'Nom requis').trim(),\r\n  phone: z.string().optional(),\r\n  acceptTerms: z.boolean().refine(val => val === true, 'Acceptation des conditions requise')\r\n})\r\n\r\nconst ResetPasswordSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis')\r\n})\r\n\r\n// ‚úÖ TYPES: Return types pour actions\r\ntype AuthActionResult = {\r\n  success: boolean\r\n  error?: string\r\n  data?: {\r\n    message?: string\r\n    email?: string\r\n    [key: string]: unknown\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Connexion utilisateur\r\n */\r\nexport async function loginAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [LOGIN-ACTION] Starting server-side login...')\r\n\r\n  // ‚úÖ PATTERN OFFICIEL NEXT.JS 15: Gestion d'erreur AVANT le try/catch principal\r\n  try {\r\n    await requireGuest()\r\n  } catch {\r\n    // Utilisateur d√©j√† connect√© - retourner succ√®s\r\n    console.log('üîÑ [LOGIN-ACTION] User already authenticated')\r\n    return { success: true, data: { message: 'Already authenticated' } }\r\n  }\r\n\r\n  // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n  let validatedData\r\n  try {\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string\r\n    }\r\n    validatedData = LoginSchema.parse(rawData)\r\n    console.log('üìù [LOGIN-ACTION] Data validated for:', validatedData.email)\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n    return { success: false, error: 'Donn√©es invalides' }\r\n  }\r\n\r\n  // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n  const supabase = await createServerSupabaseClient()\r\n  const { data, error } = await supabase.auth.signInWithPassword({\r\n    email: validatedData.email,\r\n    password: validatedData.password\r\n  })\r\n\r\n  if (error) {\r\n    console.log('‚ùå [LOGIN-ACTION] Authentication failed:', error.message)\r\n\r\n    // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n    if (error.message.includes('Invalid login credentials')) {\r\n      return { success: false, error: 'Email ou mot de passe incorrect' }\r\n    }\r\n    if (error.message.includes('Email not confirmed')) {\r\n      return { success: false, error: 'Veuillez confirmer votre email avant de vous connecter' }\r\n    }\r\n    return { success: false, error: 'Erreur de connexion : ' + error.message }\r\n  }\r\n\r\n  if (!data.user) {\r\n    return { success: false, error: 'Erreur de connexion inattendue' }\r\n  }\r\n\r\n  console.log('‚úÖ [LOGIN-ACTION] User authenticated:', data.user.email)\r\n\r\n  // ‚úÖ NOUVEAU: Attendre que la session soit bien √©tablie c√¥t√© serveur\r\n  console.log('‚è≥ [LOGIN-ACTION] Waiting for server-side session to be established...')\r\n\r\n  // Cr√©er un nouveau client server pour v√©rifier la session\r\n  const sessionSupabase = await createServerSupabaseClient()\r\n  let sessionEstablished = false\r\n  let retryCount = 0\r\n  const maxRetries = 5\r\n\r\n  while (!sessionEstablished && retryCount < maxRetries) {\r\n    try {\r\n      const { data: sessionCheck, error: sessionError } = await sessionSupabase.auth.getUser()\r\n\r\n      if (!sessionError && sessionCheck.user && sessionCheck.user.id === data.user.id) {\r\n        console.log('‚úÖ [LOGIN-ACTION] Server-side session confirmed')\r\n        sessionEstablished = true\r\n      } else {\r\n        console.log(`‚è≥ [LOGIN-ACTION] Session not ready, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n\r\n        if (retryCount < maxRetries) {\r\n          // Attendre un peu avant de retry\r\n          await new Promise(resolve => setTimeout(resolve, 200))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(`‚è≥ [LOGIN-ACTION] Session check error, retry ${retryCount + 1}/${maxRetries}:`, error instanceof Error ? error.message : String(error))\r\n      retryCount++\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 200))\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!sessionEstablished) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Session not established after retries, proceeding anyway')\r\n  }\r\n\r\n  // ‚úÖ CACHE: Invalider le cache selon les bonnes pratiques\r\n  revalidatePath('/', 'layout')\r\n\r\n  // ‚úÖ D√âTERMINER REDIRECTION: Selon le r√¥le utilisateur\r\n  let dashboardPath = '/admin/dashboard' // Fallback par d√©faut\r\n\r\n  try {\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(data.user.id)\r\n\r\n    if (userResult.success && userResult.data && userResult.data.role) {\r\n      dashboardPath = getDashboardPath(userResult.data.role)\r\n      console.log('üîÑ [LOGIN-ACTION] Redirecting to role-specific dashboard:', {\r\n        role: userResult.data.role,\r\n        dashboard: dashboardPath,\r\n        sessionEstablished\r\n      })\r\n    } else {\r\n      console.log('‚ö†Ô∏è [LOGIN-ACTION] No role found, using default dashboard')\r\n    }\r\n  } catch (error) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Error determining role, using fallback:', error)\r\n  }\r\n\r\n  // üêõ BUG INTENTIONNEL: redirect() comment√© pour tester l'auto-healing\r\n  // redirect(dashboardPath)\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Inscription utilisateur\r\n */\r\nexport async function signupAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [SIGNUP-ACTION] Starting server-side signup...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string,\r\n      firstName: formData.get('firstName') as string,\r\n      lastName: formData.get('lastName') as string,\r\n      phone: formData.get('phone') as string || undefined,\r\n      acceptTerms: formData.get('acceptTerms') === 'true'\r\n    }\r\n\r\n    const validatedData = SignupSchema.parse(rawData)\r\n    console.log('üìù [SIGNUP-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email: validatedData.email,\r\n      password: validatedData._password,\r\n      options: {\r\n        data: {\r\n          first_name: validatedData.firstName,\r\n          last_name: validatedData.lastName,\r\n          phone: validatedData.phone,\r\n          full_name: `${validatedData.firstName} ${validatedData.lastName}`\r\n        }\r\n      }\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [SIGNUP-ACTION] Signup failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User already registered')) {\r\n        return { success: false, error: 'Un compte existe d√©j√† avec cette adresse email' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de la cr√©ation du compte : ' + error.message }\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Erreur de cr√©ation de compte inattendue' }\r\n    }\r\n\r\n    console.log('‚úÖ [SIGNUP-ACTION] User created:', data.user.email)\r\n\r\n    // ‚úÖ CACHE: Invalider le cache des donn√©es auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de confirmation email\r\n    console.log('üìß [SIGNUP-ACTION] Redirecting to email confirmation page')\r\n    redirect('/auth/signup-success?email=' + encodeURIComponent(validatedData.email))\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [SIGNUP-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de la cr√©ation du compte' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: R√©initialisation mot de passe\r\n */\r\nexport async function resetPasswordAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [RESET-PASSWORD-ACTION] Starting server-side reset...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string\r\n    }\r\n\r\n    const validatedData = ResetPasswordSchema.parse(rawData)\r\n    console.log('üìù [RESET-PASSWORD-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { error } = await supabase.auth.resetPasswordForEmail(validatedData.email, {\r\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/update-password`\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [RESET-PASSWORD-ACTION] Reset failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User not found')) {\r\n        return { success: false, error: 'Aucun compte associ√© √† cette adresse email' }\r\n      }\r\n      if (error.message.includes('Email rate limit')) {\r\n        return { success: false, error: 'Trop de tentatives. Veuillez patienter avant de r√©essayer.' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de l\\'envoi de l\\'email : ' + error.message }\r\n    }\r\n\r\n    console.log('‚úÖ [RESET-PASSWORD-ACTION] Reset email sent to:', validatedData.email)\r\n\r\n    // ‚úÖ SUCC√àS: Retourner succ√®s sans redirection\r\n    return {\r\n      success: true,\r\n      data: {\r\n        message: 'Email de r√©initialisation envoy√© avec succ√®s',\r\n        email: validatedData.email\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [RESET-PASSWORD-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de l\\'envoi de l\\'email' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: D√©connexion utilisateur\r\n */\r\nexport async function logoutAction(): Promise<never> {\r\n  console.log('üöÄ [LOGOUT-ACTION] Starting server-side logout...')\r\n\r\n  try {\r\n    // ‚úÖ AUTHENTIFICATION: Invalider session\r\n    await invalidateAuth()\r\n\r\n    console.log('‚úÖ [LOGOUT-ACTION] User logged out successfully')\r\n\r\n    // ‚úÖ CACHE: Invalider tout le cache auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de connexion\r\n    redirect('/auth/login')\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [LOGOUT-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ FALLBACK: Redirection m√™me en cas d'erreur\r\n    redirect('/auth/login')\r\n  }\r\n}\r\n",
            "suspectedLines": [
              8,
              175,
              176,
              238,
              330,
              336
            ]
          },
          {
            "path": "lib/auth-dal.ts",
            "content": "/**\r\n * üõ°Ô∏è DATA ACCESS LAYER (DAL) - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Supabase 2025 :\r\n * - Centralise tous les auth checks server-side\r\n * - Utilise createServerClient pour s√©curit√© maximale\r\n * - Validation session syst√©matique avec getUser()\r\n * - Protection multi-couches (donn√©es + UI)\r\n */\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { cache } from 'react'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport type { User } from '@supabase/supabase-js'\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getUser() avec cache React et retry logic\r\n * Fonction centrale pour toute v√©rification auth server-side\r\n * Cache automatique pendant le cycle de rendu\r\n */\r\nexport const getUser = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // ‚úÖ NOUVEAU: Retry logic pour √©viter les race conditions apr√®s login\r\n  let retryCount = 0\r\n  const maxRetries = 3\r\n\r\n  while (retryCount <= maxRetries) {\r\n    try {\r\n      // ‚úÖ S√âCURIT√â: getUser() recommand√© vs getSession()\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('‚ùå [AUTH-DAL] Error getting user after retries:', error.message)\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] Error getting user, retry ${retryCount + 1}/${maxRetries}:`, error.message)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      if (!user) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('üîç [AUTH-DAL] No authenticated user found after retries')\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] No user found, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      console.log('‚úÖ [AUTH-DAL] User authenticated:', user.email)\r\n      return user\r\n    } catch (error) {\r\n      if (retryCount === maxRetries) {\r\n        console.error('‚ùå [AUTH-DAL] Exception in getUser after retries:', error)\r\n        return null\r\n      }\r\n      console.log(`‚è≥ [AUTH-DAL] Exception in getUser, retry ${retryCount + 1}/${maxRetries}:`, error)\r\n      retryCount++\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n  }\r\n\r\n  return null\r\n})\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getSession() avec validation\r\n * Pour les cas o√π on a besoin de la session compl√®te\r\n */\r\nexport const getSession = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.log('‚ùå [AUTH-DAL] Error getting session:', error.message)\r\n      return null\r\n    }\r\n\r\n    // ‚úÖ DOUBLE VALIDATION: V√©rifier que l'utilisateur existe vraiment\r\n    if (session?.user) {\r\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n      if (userError || !user) {\r\n        console.log('‚ö†Ô∏è [AUTH-DAL] Session exists but user validation failed')\r\n        return null\r\n      }\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Exception in getSession:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ PROTECTION MULTI-COUCHES: Auth check avec redirection automatique\r\n * Pour prot√©ger des pages compl√®tes\r\n */\r\nexport async function requireAuth(redirectTo: string = '/auth/login') {\r\n  const user = await getUser()\r\n\r\n  if (!user) {\r\n    console.log('üö´ [AUTH-DAL] Authentication required, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION R√îLE: V√©rification role-based access\r\n * Pour prot√©ger selon les r√¥les utilisateur\r\n */\r\nexport async function requireRole(allowedRoles: string[], redirectTo: string = '/auth/unauthorized') {\r\n  const user = await requireAuth()\r\n\r\n  // TODO: R√©cup√©rer le r√¥le depuis la base de donn√©es ou metadata\r\n  // const userRole = user.user_metadata?.role || 'user'\r\n  const userRole = 'admin' // Placeholder - √† impl√©menter selon votre logique\r\n\r\n  if (!allowedRoles.includes(userRole)) {\r\n    console.log('üö´ [AUTH-DAL] Insufficient permissions. Required:', allowedRoles, 'Got:', userRole)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return { user, role: userRole }\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION GUEST: S'assurer que l'utilisateur n'est PAS connect√©\r\n * Pour les pages comme login/signup\r\n */\r\nexport async function requireGuest(redirectTo: string = '/dashboard') {\r\n  const user = await getUser()\r\n\r\n  if (user) {\r\n    // TODO: D√©terminer redirection selon le r√¥le\r\n    console.log('üîÑ [AUTH-DAL] User already authenticated, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * ‚úÖ NOUVEAU: R√©cup√©ration profil utilisateur complet avec r√¥le\r\n * Retourne le user Supabase + profil app avec r√¥le\r\n */\r\nexport const getUserProfile = cache(async () => {\r\n  const supabaseUser = await getUser()\r\n\r\n  if (!supabaseUser) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    // ‚úÖ R√©cup√©rer le profil complet depuis la table users\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(supabaseUser.id)\r\n\r\n    if (!userResult.success || !userResult.data) {\r\n      console.log('‚ö†Ô∏è [AUTH-DAL] Supabase user exists but no profile found in users table:', supabaseUser.email)\r\n      return null\r\n    }\r\n\r\n    const userProfile = userResult.data\r\n\r\n    console.log('‚úÖ [AUTH-DAL] Complete user profile loaded:', {\r\n      email: userProfile.email,\r\n      role: userProfile.role,\r\n      id: userProfile.id\r\n    })\r\n\r\n    return {\r\n      supabaseUser,\r\n      profile: userProfile\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error loading user profile:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: D√©terminer dashboard selon le r√¥le\r\n */\r\nexport function getDashboardPath(_role: string): string {\r\n  switch (role) {\r\n    case 'admin':\r\n      return '/admin/dashboard'\r\n    case 'gestionnaire':\r\n      return '/gestionnaire/dashboard'\r\n    case 'prestataire':\r\n      return '/prestataire/dashboard'\r\n    case 'locataire':\r\n      return '/locataire/dashboard'\r\n    default:\r\n      return '/admin/dashboard' // Fallback\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: V√©rification auth sans redirection\r\n * Pour les composants qui s'adaptent selon l'√©tat auth\r\n */\r\nexport async function checkAuth() {\r\n  const user = await getUser()\r\n  const session = await getSession()\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: Server Action pour invalidation session\r\n * Peut √™tre utilis√© dans les Server Actions de d√©connexion\r\n */\r\nexport async function invalidateAuth() {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    await supabase.auth.signOut()\r\n    console.log('‚úÖ [AUTH-DAL] Session invalidated successfully')\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error invalidating session:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ OPTIMISATION: Type-safe auth state pour TypeScript\r\n */\r\nexport type AuthState = {\r\n  isAuthenticated: boolean\r\n  user: User | null\r\n  session: unknown | null\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: Helper pour Server Components\r\n * R√©cup√®re l'√©tat auth complet de mani√®re optimis√©e\r\n */\r\nexport async function getAuthState(): Promise<AuthState> {\r\n  const [user, session] = await Promise.all([\r\n    getUser(),\r\n    getSession()\r\n  ])\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n",
            "suspectedLines": [
              112,
              131,
              147
            ]
          },
          {
            "path": "app/auth/login/login-form.tsx",
            "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { useState, useActionState } from \"react\"\r\nimport { useFormStatus } from \"react-dom\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\r\nimport { Eye, EyeOff, Mail } from \"lucide-react\"\r\nimport { loginAction } from \"@/app/actions/auth-actions\"\r\n\r\n/**\r\n * üöÄ COMPOSANT CLIENT - LoginForm (Server Actions 2025)\r\n * Utilise les Server Actions pour authentification server-side s√©curis√©e\r\n */\r\n\r\n// Composant pour afficher le bouton de soumission avec √©tat\r\nfunction SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      className=\"w-full bg-primary hover:bg-secondary text-primary-foreground\"\r\n      disabled={pending}\r\n    >\r\n      {pending ? \"Connexion...\" : \"Se connecter\"}\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function LoginForm() {\r\n  const [showPassword, setShowPassword] = useState(false)\r\n  const [resendLoading, setResendLoading] = useState(false)\r\n  const [resendSuccess, setResendSuccess] = useState(false)\r\n  const [email, setEmail] = useState(\"\")\r\n\r\n  // ‚úÖ 2025: useActionState pour gestion √©tat Server Action\r\n  const [state, formAction] = useActionState(loginAction, { success: true })\r\n\r\n  // ‚úÖ LEGACY: Fonction de renvoi email (utilise ancien syst√®me pour compatibilit√©)\r\n  const handleResendConfirmation = async () => {\r\n    if (!email) {\r\n      return\r\n    }\r\n\r\n    setResendLoading(true)\r\n    setResendSuccess(false)\r\n\r\n    try {\r\n      // TODO: Migrer vers Server Action\r\n      console.log('üìß [LOGIN-FORM] Resending confirmation for:', email)\r\n      await new Promise(resolve => setTimeout(resolve, 2000))\r\n      setResendSuccess(true)\r\n    } catch (error) {\r\n      console.error('Erreur lors du renvoi de confirmation:', error)\r\n    } finally {\r\n      setResendLoading(false)\r\n    }\r\n  }\r\n\r\n  // ‚úÖ 2025: Afficher le bouton de renvoi si erreur email non confirm√©\r\n  const shouldShowResend = !state.success && state.error?.includes('confirmer votre email')\r\n\r\n  return (\r\n    <form action={formAction} className=\"space-y-4\">\r\n      {/* ‚úÖ 2025: Affichage erreurs depuis Server Action */}\r\n      {!state.success && state.error && (\r\n        <Alert variant=\"destructive\">\r\n          <AlertDescription>{state.error}</AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {resendSuccess && (\r\n        <Alert className=\"border-green-200 bg-green-50\">\r\n          <Mail className=\"h-4 w-4 text-green-600\" />\r\n          <AlertDescription className=\"text-green-800\">\r\n            Email de confirmation renvoy√© avec succ√®s ! V√©rifiez votre bo√Æte de r√©ception.\r\n          </AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {/* ‚úÖ 2025: Bouton renvoi conditionnel bas√© sur erreur Server Action */}\r\n      {shouldShowResend && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3\">\r\n          <div className=\"text-sm text-blue-800\">\r\n            <strong>Email non confirm√© ?</strong>\r\n          </div>\r\n          <p className=\"text-sm text-blue-700\">\r\n            Si vous n&apos;avez pas re√ßu l&apos;email de confirmation, vous pouvez le renvoyer.\r\n          </p>\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleResendConfirmation}\r\n            disabled={resendLoading}\r\n            className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\r\n          >\r\n            {resendLoading ? \"Envoi en cours...\" : \"Renvoyer l'email de confirmation\"}\r\n          </Button>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\" className=\"text-foreground\">\r\n          Adresse email\r\n        </Label>\r\n        <Input\r\n          id=\"email\"\r\n          name=\"email\"\r\n          type=\"email\"\r\n          placeholder=\"votre@email.com\"\r\n          value={email}\r\n          onChange={(e) => setEmail(e.target.value)}\r\n          className=\"bg-input border-border\"\r\n          required\r\n        />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"password\" className=\"text-foreground\">\r\n          Mot de passe\r\n        </Label>\r\n        <div className=\"relative\">\r\n          <Input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={showPassword ? \"text\" : \"password\"}\r\n            placeholder=\"Votre mot de passe\"\r\n            className=\"bg-input border-border pr-10\"\r\n            required\r\n          />\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n            onClick={() => setShowPassword(!showPassword)}\r\n          >\r\n            {showPassword ? (\r\n              <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\r\n            ) : (\r\n              <Eye className=\"h-4 w-4 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ‚úÖ 2025: Bouton avec √©tat Server Action */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\n",
            "suspectedLines": []
          },
          {
            "path": "middleware.ts",
            "content": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nimport { createServerClient } from '@supabase/ssr'\r\n\r\n/**\r\n * üõ°Ô∏è MIDDLEWARE AUTHENTIFICATION R√âELLE - SEIDO APP (Best Practices 2025)\r\n *\r\n * Conform√©ment aux recommandations officielles Next.js/Supabase :\r\n * - Authentification r√©elle avec supabase.auth.getUser()\r\n * - Rafra√Æchissement automatique des tokens\r\n * - Redirections serveur pour s√©curit√© optimale\r\n * - Centralis√© pour √©viter conflits avec AuthGuard client\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl\r\n\r\n  // Routes publiques (accessibles sans authentification)\r\n  const publicRoutes = [\r\n    '/auth/login',\r\n    '/auth/signup',\r\n    '/auth/signup-success',\r\n    '/auth/reset-password',\r\n    '/auth/update-password',\r\n    '/auth/callback',\r\n    '/auth/unauthorized',\r\n    '/'\r\n  ]\r\n\r\n  // Si route publique, laisser passer directement\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Routes prot√©g√©es - authentification r√©elle requise\r\n  const protectedPrefixes = ['/admin', '/gestionnaire', '/locataire', '/prestataire']\r\n  const isProtectedRoute = protectedPrefixes.some(prefix => pathname.startsWith(prefix))\r\n\r\n  if (isProtectedRoute) {\r\n    let response = NextResponse.next()\r\n\r\n    // ‚úÖ PATTERN OFFICIEL SUPABASE: Cr√©er client serveur pour middleware\r\n    const supabase = createServerClient(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return request.cookies.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              request.cookies.set(name, value)\r\n            )\r\n            response = NextResponse.next({\r\n              request: {\r\n                headers: request.headers,\r\n              },\r\n            })\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              response.cookies.set(name, value, options)\r\n            )\r\n          },\r\n        },\r\n      }\r\n    )\r\n\r\n    try {\r\n      // ‚úÖ AUTHENTIFICATION R√âELLE: V√©rifier et rafra√Æchir la session\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error || !user || !user.email_confirmed_at) {\r\n        console.log('üö´ [MIDDLEWARE] Authentication failed:', error?.message || 'No confirmed user')\r\n        return NextResponse.redirect(new URL('/auth/login?reason=session_expired', request.url))\r\n      }\r\n\r\n      console.log('‚úÖ [MIDDLEWARE] User authenticated:', user.id)\r\n\r\n      // Optionnel: V√©rification basique des r√¥les par URL\r\n      const roleFromPath = pathname.split('/')[1] // admin, gestionnaire, etc.\r\n      if (roleFromPath && ['admin', 'gestionnaire', 'locataire', 'prestataire'].includes(roleFromPath)) {\r\n        // La v√©rification d√©taill√©e des r√¥les se fera dans les Server Components avec DAL\r\n        console.log(`üîç [MIDDLEWARE] Access to ${roleFromPath} section - detailed role check in Server Component`)\r\n      }\r\n\r\n      return response\r\n\r\n    } catch (middlewareError) {\r\n      console.error('‚ùå [MIDDLEWARE] Authentication error:', middlewareError)\r\n      return NextResponse.redirect(new URL('/auth/login?reason=auth_error', request.url))\r\n    }\r\n  }\r\n\r\n  // Routes syst√®me/API ‚Üí laisser passer\r\n  return NextResponse.next()\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public files (public folder)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n}\r\n",
            "suspectedLines": [
              73,
              89
            ]
          }
        ],
        "previousAttempts": []
      },
      "fixApplied": {
        "success": true,
        "correction": {
          "description": "Fixed Server Action redirect by restructuring async flow",
          "filesModified": [
            {
              "path": "app/actions/auth-actions.ts",
              "changes": "Added missing redirect(dashboardPath) call outside try/catch block following Next.js 15 Server Action best practices",
              "backup": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\backups\\auth-actions.ts.backup"
            }
          ],
          "confidence": "high"
        }
      },
      "testResult": {
        "passed": false,
        "duration": 0
      },
      "artifacts": {
        "screenshots": [
          "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png"
        ],
        "logs": [],
        "diffs": []
      }
    },
    {
      "cycleNumber": 2,
      "startTime": "2025-09-30T10:57:20.500Z",
      "endTime": "2025-09-30T10:57:23.527Z",
      "duration": 3027,
      "errorContext": {
        "testId": "auto-heal-login-1759229818815",
        "testName": "login-admin-auto-heal",
        "userRole": "admin",
        "error": {
          "type": "redirect",
          "message": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================",
          "stack": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================\n    at C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing\\demo-login-test.spec.ts:62:22",
          "step": "waitForURL",
          "timestamp": "2025-09-30T10:57:14.470Z"
        },
        "state": {
          "url": "http://localhost:3000/auth/login",
          "expectedUrl": "/admin/dashboard",
          "screenshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png",
          "domSnapshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\dom-snapshot.html",
          "networkLogs": [],
          "consoleLogs": []
        },
        "sourceFiles": [
          {
            "path": "app/actions/auth-actions.ts",
            "content": "/**\r\n * üöÄ SERVER ACTIONS - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Server Actions :\r\n * - Authentification server-side s√©curis√©e\r\n * - Validation c√¥t√© serveur syst√©matique\r\n * - Gestion erreurs appropri√©e\r\n * - Redirections s√©curis√©es avec redirect()\r\n */\r\n\r\n'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { requireGuest, invalidateAuth, getDashboardPath } from '@/lib/auth-dal'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport { z } from 'zod'\r\n\r\n// ‚úÖ VALIDATION: Schemas Zod pour s√©curit√© server-side\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string().min(1, 'Mot de passe requis')\r\n})\r\n\r\nconst SignupSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string()\r\n    .min(8, 'Au moins 8 caract√®res')\r\n    .regex(/[A-Z]/, 'Une majuscule requise')\r\n    .regex(/[a-z]/, 'Une minuscule requise')\r\n    .regex(/\\d/, 'Un chiffre requis'),\r\n  firstName: z.string().min(1, 'Pr√©nom requis').trim(),\r\n  lastName: z.string().min(1, 'Nom requis').trim(),\r\n  phone: z.string().optional(),\r\n  acceptTerms: z.boolean().refine(val => val === true, 'Acceptation des conditions requise')\r\n})\r\n\r\nconst ResetPasswordSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis')\r\n})\r\n\r\n// ‚úÖ TYPES: Return types pour actions\r\ntype AuthActionResult = {\r\n  success: boolean\r\n  error?: string\r\n  data?: {\r\n    message?: string\r\n    email?: string\r\n    [key: string]: unknown\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Connexion utilisateur\r\n */\r\nexport async function loginAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [LOGIN-ACTION] Starting server-side login...')\r\n\r\n  // ‚úÖ PATTERN OFFICIEL NEXT.JS 15: Gestion d'erreur AVANT le try/catch principal\r\n  try {\r\n    await requireGuest()\r\n  } catch {\r\n    // Utilisateur d√©j√† connect√© - retourner succ√®s\r\n    console.log('üîÑ [LOGIN-ACTION] User already authenticated')\r\n    return { success: true, data: { message: 'Already authenticated' } }\r\n  }\r\n\r\n  // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n  let validatedData\r\n  try {\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string\r\n    }\r\n    validatedData = LoginSchema.parse(rawData)\r\n    console.log('üìù [LOGIN-ACTION] Data validated for:', validatedData.email)\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n    return { success: false, error: 'Donn√©es invalides' }\r\n  }\r\n\r\n  // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n  const supabase = await createServerSupabaseClient()\r\n  const { data, error } = await supabase.auth.signInWithPassword({\r\n    email: validatedData.email,\r\n    password: validatedData.password\r\n  })\r\n\r\n  if (error) {\r\n    console.log('‚ùå [LOGIN-ACTION] Authentication failed:', error.message)\r\n\r\n    // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n    if (error.message.includes('Invalid login credentials')) {\r\n      return { success: false, error: 'Email ou mot de passe incorrect' }\r\n    }\r\n    if (error.message.includes('Email not confirmed')) {\r\n      return { success: false, error: 'Veuillez confirmer votre email avant de vous connecter' }\r\n    }\r\n    return { success: false, error: 'Erreur de connexion : ' + error.message }\r\n  }\r\n\r\n  if (!data.user) {\r\n    return { success: false, error: 'Erreur de connexion inattendue' }\r\n  }\r\n\r\n  console.log('‚úÖ [LOGIN-ACTION] User authenticated:', data.user.email)\r\n\r\n  // ‚úÖ NOUVEAU: Attendre que la session soit bien √©tablie c√¥t√© serveur\r\n  console.log('‚è≥ [LOGIN-ACTION] Waiting for server-side session to be established...')\r\n\r\n  // Cr√©er un nouveau client server pour v√©rifier la session\r\n  const sessionSupabase = await createServerSupabaseClient()\r\n  let sessionEstablished = false\r\n  let retryCount = 0\r\n  const maxRetries = 5\r\n\r\n  while (!sessionEstablished && retryCount < maxRetries) {\r\n    try {\r\n      const { data: sessionCheck, error: sessionError } = await sessionSupabase.auth.getUser()\r\n\r\n      if (!sessionError && sessionCheck.user && sessionCheck.user.id === data.user.id) {\r\n        console.log('‚úÖ [LOGIN-ACTION] Server-side session confirmed')\r\n        sessionEstablished = true\r\n      } else {\r\n        console.log(`‚è≥ [LOGIN-ACTION] Session not ready, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n\r\n        if (retryCount < maxRetries) {\r\n          // Attendre un peu avant de retry\r\n          await new Promise(resolve => setTimeout(resolve, 200))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(`‚è≥ [LOGIN-ACTION] Session check error, retry ${retryCount + 1}/${maxRetries}:`, error instanceof Error ? error.message : String(error))\r\n      retryCount++\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 200))\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!sessionEstablished) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Session not established after retries, proceeding anyway')\r\n  }\r\n\r\n  // ‚úÖ CACHE: Invalider le cache selon les bonnes pratiques\r\n  revalidatePath('/', 'layout')\r\n\r\n  // ‚úÖ D√âTERMINER REDIRECTION: Selon le r√¥le utilisateur\r\n  let dashboardPath = '/admin/dashboard' // Fallback par d√©faut\r\n\r\n  try {\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(data.user.id)\r\n\r\n    if (userResult.success && userResult.data && userResult.data.role) {\r\n      dashboardPath = getDashboardPath(userResult.data.role)\r\n      console.log('üîÑ [LOGIN-ACTION] Redirecting to role-specific dashboard:', {\r\n        role: userResult.data.role,\r\n        dashboard: dashboardPath,\r\n        sessionEstablished\r\n      })\r\n    } else {\r\n      console.log('‚ö†Ô∏è [LOGIN-ACTION] No role found, using default dashboard')\r\n    }\r\n  } catch (error) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Error determining role, using fallback:', error)\r\n  }\r\n\r\n  // üêõ BUG INTENTIONNEL: redirect() comment√© pour tester l'auto-healing\r\n  // redirect(dashboardPath)\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Inscription utilisateur\r\n */\r\nexport async function signupAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [SIGNUP-ACTION] Starting server-side signup...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string,\r\n      firstName: formData.get('firstName') as string,\r\n      lastName: formData.get('lastName') as string,\r\n      phone: formData.get('phone') as string || undefined,\r\n      acceptTerms: formData.get('acceptTerms') === 'true'\r\n    }\r\n\r\n    const validatedData = SignupSchema.parse(rawData)\r\n    console.log('üìù [SIGNUP-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email: validatedData.email,\r\n      password: validatedData._password,\r\n      options: {\r\n        data: {\r\n          first_name: validatedData.firstName,\r\n          last_name: validatedData.lastName,\r\n          phone: validatedData.phone,\r\n          full_name: `${validatedData.firstName} ${validatedData.lastName}`\r\n        }\r\n      }\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [SIGNUP-ACTION] Signup failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User already registered')) {\r\n        return { success: false, error: 'Un compte existe d√©j√† avec cette adresse email' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de la cr√©ation du compte : ' + error.message }\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Erreur de cr√©ation de compte inattendue' }\r\n    }\r\n\r\n    console.log('‚úÖ [SIGNUP-ACTION] User created:', data.user.email)\r\n\r\n    // ‚úÖ CACHE: Invalider le cache des donn√©es auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de confirmation email\r\n    console.log('üìß [SIGNUP-ACTION] Redirecting to email confirmation page')\r\n    redirect('/auth/signup-success?email=' + encodeURIComponent(validatedData.email))\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [SIGNUP-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de la cr√©ation du compte' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: R√©initialisation mot de passe\r\n */\r\nexport async function resetPasswordAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [RESET-PASSWORD-ACTION] Starting server-side reset...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string\r\n    }\r\n\r\n    const validatedData = ResetPasswordSchema.parse(rawData)\r\n    console.log('üìù [RESET-PASSWORD-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { error } = await supabase.auth.resetPasswordForEmail(validatedData.email, {\r\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/update-password`\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [RESET-PASSWORD-ACTION] Reset failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User not found')) {\r\n        return { success: false, error: 'Aucun compte associ√© √† cette adresse email' }\r\n      }\r\n      if (error.message.includes('Email rate limit')) {\r\n        return { success: false, error: 'Trop de tentatives. Veuillez patienter avant de r√©essayer.' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de l\\'envoi de l\\'email : ' + error.message }\r\n    }\r\n\r\n    console.log('‚úÖ [RESET-PASSWORD-ACTION] Reset email sent to:', validatedData.email)\r\n\r\n    // ‚úÖ SUCC√àS: Retourner succ√®s sans redirection\r\n    return {\r\n      success: true,\r\n      data: {\r\n        message: 'Email de r√©initialisation envoy√© avec succ√®s',\r\n        email: validatedData.email\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [RESET-PASSWORD-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de l\\'envoi de l\\'email' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: D√©connexion utilisateur\r\n */\r\nexport async function logoutAction(): Promise<never> {\r\n  console.log('üöÄ [LOGOUT-ACTION] Starting server-side logout...')\r\n\r\n  try {\r\n    // ‚úÖ AUTHENTIFICATION: Invalider session\r\n    await invalidateAuth()\r\n\r\n    console.log('‚úÖ [LOGOUT-ACTION] User logged out successfully')\r\n\r\n    // ‚úÖ CACHE: Invalider tout le cache auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de connexion\r\n    redirect('/auth/login')\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [LOGOUT-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ FALLBACK: Redirection m√™me en cas d'erreur\r\n    redirect('/auth/login')\r\n  }\r\n}\r\n",
            "suspectedLines": [
              8,
              175,
              176,
              238,
              330,
              336
            ]
          },
          {
            "path": "lib/auth-dal.ts",
            "content": "/**\r\n * üõ°Ô∏è DATA ACCESS LAYER (DAL) - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Supabase 2025 :\r\n * - Centralise tous les auth checks server-side\r\n * - Utilise createServerClient pour s√©curit√© maximale\r\n * - Validation session syst√©matique avec getUser()\r\n * - Protection multi-couches (donn√©es + UI)\r\n */\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { cache } from 'react'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport type { User } from '@supabase/supabase-js'\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getUser() avec cache React et retry logic\r\n * Fonction centrale pour toute v√©rification auth server-side\r\n * Cache automatique pendant le cycle de rendu\r\n */\r\nexport const getUser = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // ‚úÖ NOUVEAU: Retry logic pour √©viter les race conditions apr√®s login\r\n  let retryCount = 0\r\n  const maxRetries = 3\r\n\r\n  while (retryCount <= maxRetries) {\r\n    try {\r\n      // ‚úÖ S√âCURIT√â: getUser() recommand√© vs getSession()\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('‚ùå [AUTH-DAL] Error getting user after retries:', error.message)\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] Error getting user, retry ${retryCount + 1}/${maxRetries}:`, error.message)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      if (!user) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('üîç [AUTH-DAL] No authenticated user found after retries')\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] No user found, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      console.log('‚úÖ [AUTH-DAL] User authenticated:', user.email)\r\n      return user\r\n    } catch (error) {\r\n      if (retryCount === maxRetries) {\r\n        console.error('‚ùå [AUTH-DAL] Exception in getUser after retries:', error)\r\n        return null\r\n      }\r\n      console.log(`‚è≥ [AUTH-DAL] Exception in getUser, retry ${retryCount + 1}/${maxRetries}:`, error)\r\n      retryCount++\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n  }\r\n\r\n  return null\r\n})\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getSession() avec validation\r\n * Pour les cas o√π on a besoin de la session compl√®te\r\n */\r\nexport const getSession = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.log('‚ùå [AUTH-DAL] Error getting session:', error.message)\r\n      return null\r\n    }\r\n\r\n    // ‚úÖ DOUBLE VALIDATION: V√©rifier que l'utilisateur existe vraiment\r\n    if (session?.user) {\r\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n      if (userError || !user) {\r\n        console.log('‚ö†Ô∏è [AUTH-DAL] Session exists but user validation failed')\r\n        return null\r\n      }\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Exception in getSession:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ PROTECTION MULTI-COUCHES: Auth check avec redirection automatique\r\n * Pour prot√©ger des pages compl√®tes\r\n */\r\nexport async function requireAuth(redirectTo: string = '/auth/login') {\r\n  const user = await getUser()\r\n\r\n  if (!user) {\r\n    console.log('üö´ [AUTH-DAL] Authentication required, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION R√îLE: V√©rification role-based access\r\n * Pour prot√©ger selon les r√¥les utilisateur\r\n */\r\nexport async function requireRole(allowedRoles: string[], redirectTo: string = '/auth/unauthorized') {\r\n  const user = await requireAuth()\r\n\r\n  // TODO: R√©cup√©rer le r√¥le depuis la base de donn√©es ou metadata\r\n  // const userRole = user.user_metadata?.role || 'user'\r\n  const userRole = 'admin' // Placeholder - √† impl√©menter selon votre logique\r\n\r\n  if (!allowedRoles.includes(userRole)) {\r\n    console.log('üö´ [AUTH-DAL] Insufficient permissions. Required:', allowedRoles, 'Got:', userRole)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return { user, role: userRole }\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION GUEST: S'assurer que l'utilisateur n'est PAS connect√©\r\n * Pour les pages comme login/signup\r\n */\r\nexport async function requireGuest(redirectTo: string = '/dashboard') {\r\n  const user = await getUser()\r\n\r\n  if (user) {\r\n    // TODO: D√©terminer redirection selon le r√¥le\r\n    console.log('üîÑ [AUTH-DAL] User already authenticated, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * ‚úÖ NOUVEAU: R√©cup√©ration profil utilisateur complet avec r√¥le\r\n * Retourne le user Supabase + profil app avec r√¥le\r\n */\r\nexport const getUserProfile = cache(async () => {\r\n  const supabaseUser = await getUser()\r\n\r\n  if (!supabaseUser) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    // ‚úÖ R√©cup√©rer le profil complet depuis la table users\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(supabaseUser.id)\r\n\r\n    if (!userResult.success || !userResult.data) {\r\n      console.log('‚ö†Ô∏è [AUTH-DAL] Supabase user exists but no profile found in users table:', supabaseUser.email)\r\n      return null\r\n    }\r\n\r\n    const userProfile = userResult.data\r\n\r\n    console.log('‚úÖ [AUTH-DAL] Complete user profile loaded:', {\r\n      email: userProfile.email,\r\n      role: userProfile.role,\r\n      id: userProfile.id\r\n    })\r\n\r\n    return {\r\n      supabaseUser,\r\n      profile: userProfile\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error loading user profile:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: D√©terminer dashboard selon le r√¥le\r\n */\r\nexport function getDashboardPath(_role: string): string {\r\n  switch (role) {\r\n    case 'admin':\r\n      return '/admin/dashboard'\r\n    case 'gestionnaire':\r\n      return '/gestionnaire/dashboard'\r\n    case 'prestataire':\r\n      return '/prestataire/dashboard'\r\n    case 'locataire':\r\n      return '/locataire/dashboard'\r\n    default:\r\n      return '/admin/dashboard' // Fallback\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: V√©rification auth sans redirection\r\n * Pour les composants qui s'adaptent selon l'√©tat auth\r\n */\r\nexport async function checkAuth() {\r\n  const user = await getUser()\r\n  const session = await getSession()\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: Server Action pour invalidation session\r\n * Peut √™tre utilis√© dans les Server Actions de d√©connexion\r\n */\r\nexport async function invalidateAuth() {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    await supabase.auth.signOut()\r\n    console.log('‚úÖ [AUTH-DAL] Session invalidated successfully')\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error invalidating session:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ OPTIMISATION: Type-safe auth state pour TypeScript\r\n */\r\nexport type AuthState = {\r\n  isAuthenticated: boolean\r\n  user: User | null\r\n  session: unknown | null\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: Helper pour Server Components\r\n * R√©cup√®re l'√©tat auth complet de mani√®re optimis√©e\r\n */\r\nexport async function getAuthState(): Promise<AuthState> {\r\n  const [user, session] = await Promise.all([\r\n    getUser(),\r\n    getSession()\r\n  ])\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n",
            "suspectedLines": [
              112,
              131,
              147
            ]
          },
          {
            "path": "app/auth/login/login-form.tsx",
            "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { useState, useActionState } from \"react\"\r\nimport { useFormStatus } from \"react-dom\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\r\nimport { Eye, EyeOff, Mail } from \"lucide-react\"\r\nimport { loginAction } from \"@/app/actions/auth-actions\"\r\n\r\n/**\r\n * üöÄ COMPOSANT CLIENT - LoginForm (Server Actions 2025)\r\n * Utilise les Server Actions pour authentification server-side s√©curis√©e\r\n */\r\n\r\n// Composant pour afficher le bouton de soumission avec √©tat\r\nfunction SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      className=\"w-full bg-primary hover:bg-secondary text-primary-foreground\"\r\n      disabled={pending}\r\n    >\r\n      {pending ? \"Connexion...\" : \"Se connecter\"}\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function LoginForm() {\r\n  const [showPassword, setShowPassword] = useState(false)\r\n  const [resendLoading, setResendLoading] = useState(false)\r\n  const [resendSuccess, setResendSuccess] = useState(false)\r\n  const [email, setEmail] = useState(\"\")\r\n\r\n  // ‚úÖ 2025: useActionState pour gestion √©tat Server Action\r\n  const [state, formAction] = useActionState(loginAction, { success: true })\r\n\r\n  // ‚úÖ LEGACY: Fonction de renvoi email (utilise ancien syst√®me pour compatibilit√©)\r\n  const handleResendConfirmation = async () => {\r\n    if (!email) {\r\n      return\r\n    }\r\n\r\n    setResendLoading(true)\r\n    setResendSuccess(false)\r\n\r\n    try {\r\n      // TODO: Migrer vers Server Action\r\n      console.log('üìß [LOGIN-FORM] Resending confirmation for:', email)\r\n      await new Promise(resolve => setTimeout(resolve, 2000))\r\n      setResendSuccess(true)\r\n    } catch (error) {\r\n      console.error('Erreur lors du renvoi de confirmation:', error)\r\n    } finally {\r\n      setResendLoading(false)\r\n    }\r\n  }\r\n\r\n  // ‚úÖ 2025: Afficher le bouton de renvoi si erreur email non confirm√©\r\n  const shouldShowResend = !state.success && state.error?.includes('confirmer votre email')\r\n\r\n  return (\r\n    <form action={formAction} className=\"space-y-4\">\r\n      {/* ‚úÖ 2025: Affichage erreurs depuis Server Action */}\r\n      {!state.success && state.error && (\r\n        <Alert variant=\"destructive\">\r\n          <AlertDescription>{state.error}</AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {resendSuccess && (\r\n        <Alert className=\"border-green-200 bg-green-50\">\r\n          <Mail className=\"h-4 w-4 text-green-600\" />\r\n          <AlertDescription className=\"text-green-800\">\r\n            Email de confirmation renvoy√© avec succ√®s ! V√©rifiez votre bo√Æte de r√©ception.\r\n          </AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {/* ‚úÖ 2025: Bouton renvoi conditionnel bas√© sur erreur Server Action */}\r\n      {shouldShowResend && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3\">\r\n          <div className=\"text-sm text-blue-800\">\r\n            <strong>Email non confirm√© ?</strong>\r\n          </div>\r\n          <p className=\"text-sm text-blue-700\">\r\n            Si vous n&apos;avez pas re√ßu l&apos;email de confirmation, vous pouvez le renvoyer.\r\n          </p>\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleResendConfirmation}\r\n            disabled={resendLoading}\r\n            className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\r\n          >\r\n            {resendLoading ? \"Envoi en cours...\" : \"Renvoyer l'email de confirmation\"}\r\n          </Button>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\" className=\"text-foreground\">\r\n          Adresse email\r\n        </Label>\r\n        <Input\r\n          id=\"email\"\r\n          name=\"email\"\r\n          type=\"email\"\r\n          placeholder=\"votre@email.com\"\r\n          value={email}\r\n          onChange={(e) => setEmail(e.target.value)}\r\n          className=\"bg-input border-border\"\r\n          required\r\n        />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"password\" className=\"text-foreground\">\r\n          Mot de passe\r\n        </Label>\r\n        <div className=\"relative\">\r\n          <Input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={showPassword ? \"text\" : \"password\"}\r\n            placeholder=\"Votre mot de passe\"\r\n            className=\"bg-input border-border pr-10\"\r\n            required\r\n          />\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n            onClick={() => setShowPassword(!showPassword)}\r\n          >\r\n            {showPassword ? (\r\n              <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\r\n            ) : (\r\n              <Eye className=\"h-4 w-4 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ‚úÖ 2025: Bouton avec √©tat Server Action */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\n",
            "suspectedLines": []
          },
          {
            "path": "middleware.ts",
            "content": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nimport { createServerClient } from '@supabase/ssr'\r\n\r\n/**\r\n * üõ°Ô∏è MIDDLEWARE AUTHENTIFICATION R√âELLE - SEIDO APP (Best Practices 2025)\r\n *\r\n * Conform√©ment aux recommandations officielles Next.js/Supabase :\r\n * - Authentification r√©elle avec supabase.auth.getUser()\r\n * - Rafra√Æchissement automatique des tokens\r\n * - Redirections serveur pour s√©curit√© optimale\r\n * - Centralis√© pour √©viter conflits avec AuthGuard client\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl\r\n\r\n  // Routes publiques (accessibles sans authentification)\r\n  const publicRoutes = [\r\n    '/auth/login',\r\n    '/auth/signup',\r\n    '/auth/signup-success',\r\n    '/auth/reset-password',\r\n    '/auth/update-password',\r\n    '/auth/callback',\r\n    '/auth/unauthorized',\r\n    '/'\r\n  ]\r\n\r\n  // Si route publique, laisser passer directement\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Routes prot√©g√©es - authentification r√©elle requise\r\n  const protectedPrefixes = ['/admin', '/gestionnaire', '/locataire', '/prestataire']\r\n  const isProtectedRoute = protectedPrefixes.some(prefix => pathname.startsWith(prefix))\r\n\r\n  if (isProtectedRoute) {\r\n    let response = NextResponse.next()\r\n\r\n    // ‚úÖ PATTERN OFFICIEL SUPABASE: Cr√©er client serveur pour middleware\r\n    const supabase = createServerClient(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return request.cookies.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              request.cookies.set(name, value)\r\n            )\r\n            response = NextResponse.next({\r\n              request: {\r\n                headers: request.headers,\r\n              },\r\n            })\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              response.cookies.set(name, value, options)\r\n            )\r\n          },\r\n        },\r\n      }\r\n    )\r\n\r\n    try {\r\n      // ‚úÖ AUTHENTIFICATION R√âELLE: V√©rifier et rafra√Æchir la session\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error || !user || !user.email_confirmed_at) {\r\n        console.log('üö´ [MIDDLEWARE] Authentication failed:', error?.message || 'No confirmed user')\r\n        return NextResponse.redirect(new URL('/auth/login?reason=session_expired', request.url))\r\n      }\r\n\r\n      console.log('‚úÖ [MIDDLEWARE] User authenticated:', user.id)\r\n\r\n      // Optionnel: V√©rification basique des r√¥les par URL\r\n      const roleFromPath = pathname.split('/')[1] // admin, gestionnaire, etc.\r\n      if (roleFromPath && ['admin', 'gestionnaire', 'locataire', 'prestataire'].includes(roleFromPath)) {\r\n        // La v√©rification d√©taill√©e des r√¥les se fera dans les Server Components avec DAL\r\n        console.log(`üîç [MIDDLEWARE] Access to ${roleFromPath} section - detailed role check in Server Component`)\r\n      }\r\n\r\n      return response\r\n\r\n    } catch (middlewareError) {\r\n      console.error('‚ùå [MIDDLEWARE] Authentication error:', middlewareError)\r\n      return NextResponse.redirect(new URL('/auth/login?reason=auth_error', request.url))\r\n    }\r\n  }\r\n\r\n  // Routes syst√®me/API ‚Üí laisser passer\r\n  return NextResponse.next()\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public files (public folder)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n}\r\n",
            "suspectedLines": [
              73,
              89
            ]
          }
        ],
        "previousAttempts": []
      },
      "fixApplied": {
        "success": true,
        "correction": {
          "description": "Fixed Server Action redirect by restructuring async flow",
          "filesModified": [
            {
              "path": "app/actions/auth-actions.ts",
              "changes": "Added missing redirect(dashboardPath) call outside try/catch block following Next.js 15 Server Action best practices",
              "backup": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\backups\\auth-actions.ts.backup"
            }
          ],
          "confidence": "high"
        }
      },
      "testResult": {
        "passed": false,
        "duration": 0
      },
      "artifacts": {
        "screenshots": [
          "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png"
        ],
        "logs": [],
        "diffs": []
      }
    },
    {
      "cycleNumber": 3,
      "startTime": "2025-09-30T10:57:26.530Z",
      "endTime": "2025-09-30T10:57:29.546Z",
      "duration": 3016,
      "errorContext": {
        "testId": "auto-heal-login-1759229818815",
        "testName": "login-admin-auto-heal",
        "userRole": "admin",
        "error": {
          "type": "redirect",
          "message": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================",
          "stack": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================\n    at C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing\\demo-login-test.spec.ts:62:22",
          "step": "waitForURL",
          "timestamp": "2025-09-30T10:57:14.470Z"
        },
        "state": {
          "url": "http://localhost:3000/auth/login",
          "expectedUrl": "/admin/dashboard",
          "screenshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png",
          "domSnapshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\dom-snapshot.html",
          "networkLogs": [],
          "consoleLogs": []
        },
        "sourceFiles": [
          {
            "path": "app/actions/auth-actions.ts",
            "content": "/**\r\n * üöÄ SERVER ACTIONS - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Server Actions :\r\n * - Authentification server-side s√©curis√©e\r\n * - Validation c√¥t√© serveur syst√©matique\r\n * - Gestion erreurs appropri√©e\r\n * - Redirections s√©curis√©es avec redirect()\r\n */\r\n\r\n'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { requireGuest, invalidateAuth, getDashboardPath } from '@/lib/auth-dal'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport { z } from 'zod'\r\n\r\n// ‚úÖ VALIDATION: Schemas Zod pour s√©curit√© server-side\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string().min(1, 'Mot de passe requis')\r\n})\r\n\r\nconst SignupSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string()\r\n    .min(8, 'Au moins 8 caract√®res')\r\n    .regex(/[A-Z]/, 'Une majuscule requise')\r\n    .regex(/[a-z]/, 'Une minuscule requise')\r\n    .regex(/\\d/, 'Un chiffre requis'),\r\n  firstName: z.string().min(1, 'Pr√©nom requis').trim(),\r\n  lastName: z.string().min(1, 'Nom requis').trim(),\r\n  phone: z.string().optional(),\r\n  acceptTerms: z.boolean().refine(val => val === true, 'Acceptation des conditions requise')\r\n})\r\n\r\nconst ResetPasswordSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis')\r\n})\r\n\r\n// ‚úÖ TYPES: Return types pour actions\r\ntype AuthActionResult = {\r\n  success: boolean\r\n  error?: string\r\n  data?: {\r\n    message?: string\r\n    email?: string\r\n    [key: string]: unknown\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Connexion utilisateur\r\n */\r\nexport async function loginAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [LOGIN-ACTION] Starting server-side login...')\r\n\r\n  // ‚úÖ PATTERN OFFICIEL NEXT.JS 15: Gestion d'erreur AVANT le try/catch principal\r\n  try {\r\n    await requireGuest()\r\n  } catch {\r\n    // Utilisateur d√©j√† connect√© - retourner succ√®s\r\n    console.log('üîÑ [LOGIN-ACTION] User already authenticated')\r\n    return { success: true, data: { message: 'Already authenticated' } }\r\n  }\r\n\r\n  // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n  let validatedData\r\n  try {\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string\r\n    }\r\n    validatedData = LoginSchema.parse(rawData)\r\n    console.log('üìù [LOGIN-ACTION] Data validated for:', validatedData.email)\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n    return { success: false, error: 'Donn√©es invalides' }\r\n  }\r\n\r\n  // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n  const supabase = await createServerSupabaseClient()\r\n  const { data, error } = await supabase.auth.signInWithPassword({\r\n    email: validatedData.email,\r\n    password: validatedData.password\r\n  })\r\n\r\n  if (error) {\r\n    console.log('‚ùå [LOGIN-ACTION] Authentication failed:', error.message)\r\n\r\n    // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n    if (error.message.includes('Invalid login credentials')) {\r\n      return { success: false, error: 'Email ou mot de passe incorrect' }\r\n    }\r\n    if (error.message.includes('Email not confirmed')) {\r\n      return { success: false, error: 'Veuillez confirmer votre email avant de vous connecter' }\r\n    }\r\n    return { success: false, error: 'Erreur de connexion : ' + error.message }\r\n  }\r\n\r\n  if (!data.user) {\r\n    return { success: false, error: 'Erreur de connexion inattendue' }\r\n  }\r\n\r\n  console.log('‚úÖ [LOGIN-ACTION] User authenticated:', data.user.email)\r\n\r\n  // ‚úÖ NOUVEAU: Attendre que la session soit bien √©tablie c√¥t√© serveur\r\n  console.log('‚è≥ [LOGIN-ACTION] Waiting for server-side session to be established...')\r\n\r\n  // Cr√©er un nouveau client server pour v√©rifier la session\r\n  const sessionSupabase = await createServerSupabaseClient()\r\n  let sessionEstablished = false\r\n  let retryCount = 0\r\n  const maxRetries = 5\r\n\r\n  while (!sessionEstablished && retryCount < maxRetries) {\r\n    try {\r\n      const { data: sessionCheck, error: sessionError } = await sessionSupabase.auth.getUser()\r\n\r\n      if (!sessionError && sessionCheck.user && sessionCheck.user.id === data.user.id) {\r\n        console.log('‚úÖ [LOGIN-ACTION] Server-side session confirmed')\r\n        sessionEstablished = true\r\n      } else {\r\n        console.log(`‚è≥ [LOGIN-ACTION] Session not ready, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n\r\n        if (retryCount < maxRetries) {\r\n          // Attendre un peu avant de retry\r\n          await new Promise(resolve => setTimeout(resolve, 200))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(`‚è≥ [LOGIN-ACTION] Session check error, retry ${retryCount + 1}/${maxRetries}:`, error instanceof Error ? error.message : String(error))\r\n      retryCount++\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 200))\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!sessionEstablished) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Session not established after retries, proceeding anyway')\r\n  }\r\n\r\n  // ‚úÖ CACHE: Invalider le cache selon les bonnes pratiques\r\n  revalidatePath('/', 'layout')\r\n\r\n  // ‚úÖ D√âTERMINER REDIRECTION: Selon le r√¥le utilisateur\r\n  let dashboardPath = '/admin/dashboard' // Fallback par d√©faut\r\n\r\n  try {\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(data.user.id)\r\n\r\n    if (userResult.success && userResult.data && userResult.data.role) {\r\n      dashboardPath = getDashboardPath(userResult.data.role)\r\n      console.log('üîÑ [LOGIN-ACTION] Redirecting to role-specific dashboard:', {\r\n        role: userResult.data.role,\r\n        dashboard: dashboardPath,\r\n        sessionEstablished\r\n      })\r\n    } else {\r\n      console.log('‚ö†Ô∏è [LOGIN-ACTION] No role found, using default dashboard')\r\n    }\r\n  } catch (error) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Error determining role, using fallback:', error)\r\n  }\r\n\r\n  // üêõ BUG INTENTIONNEL: redirect() comment√© pour tester l'auto-healing\r\n  // redirect(dashboardPath)\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Inscription utilisateur\r\n */\r\nexport async function signupAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [SIGNUP-ACTION] Starting server-side signup...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string,\r\n      firstName: formData.get('firstName') as string,\r\n      lastName: formData.get('lastName') as string,\r\n      phone: formData.get('phone') as string || undefined,\r\n      acceptTerms: formData.get('acceptTerms') === 'true'\r\n    }\r\n\r\n    const validatedData = SignupSchema.parse(rawData)\r\n    console.log('üìù [SIGNUP-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email: validatedData.email,\r\n      password: validatedData._password,\r\n      options: {\r\n        data: {\r\n          first_name: validatedData.firstName,\r\n          last_name: validatedData.lastName,\r\n          phone: validatedData.phone,\r\n          full_name: `${validatedData.firstName} ${validatedData.lastName}`\r\n        }\r\n      }\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [SIGNUP-ACTION] Signup failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User already registered')) {\r\n        return { success: false, error: 'Un compte existe d√©j√† avec cette adresse email' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de la cr√©ation du compte : ' + error.message }\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Erreur de cr√©ation de compte inattendue' }\r\n    }\r\n\r\n    console.log('‚úÖ [SIGNUP-ACTION] User created:', data.user.email)\r\n\r\n    // ‚úÖ CACHE: Invalider le cache des donn√©es auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de confirmation email\r\n    console.log('üìß [SIGNUP-ACTION] Redirecting to email confirmation page')\r\n    redirect('/auth/signup-success?email=' + encodeURIComponent(validatedData.email))\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [SIGNUP-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de la cr√©ation du compte' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: R√©initialisation mot de passe\r\n */\r\nexport async function resetPasswordAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [RESET-PASSWORD-ACTION] Starting server-side reset...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string\r\n    }\r\n\r\n    const validatedData = ResetPasswordSchema.parse(rawData)\r\n    console.log('üìù [RESET-PASSWORD-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { error } = await supabase.auth.resetPasswordForEmail(validatedData.email, {\r\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/update-password`\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [RESET-PASSWORD-ACTION] Reset failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User not found')) {\r\n        return { success: false, error: 'Aucun compte associ√© √† cette adresse email' }\r\n      }\r\n      if (error.message.includes('Email rate limit')) {\r\n        return { success: false, error: 'Trop de tentatives. Veuillez patienter avant de r√©essayer.' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de l\\'envoi de l\\'email : ' + error.message }\r\n    }\r\n\r\n    console.log('‚úÖ [RESET-PASSWORD-ACTION] Reset email sent to:', validatedData.email)\r\n\r\n    // ‚úÖ SUCC√àS: Retourner succ√®s sans redirection\r\n    return {\r\n      success: true,\r\n      data: {\r\n        message: 'Email de r√©initialisation envoy√© avec succ√®s',\r\n        email: validatedData.email\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [RESET-PASSWORD-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de l\\'envoi de l\\'email' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: D√©connexion utilisateur\r\n */\r\nexport async function logoutAction(): Promise<never> {\r\n  console.log('üöÄ [LOGOUT-ACTION] Starting server-side logout...')\r\n\r\n  try {\r\n    // ‚úÖ AUTHENTIFICATION: Invalider session\r\n    await invalidateAuth()\r\n\r\n    console.log('‚úÖ [LOGOUT-ACTION] User logged out successfully')\r\n\r\n    // ‚úÖ CACHE: Invalider tout le cache auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de connexion\r\n    redirect('/auth/login')\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [LOGOUT-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ FALLBACK: Redirection m√™me en cas d'erreur\r\n    redirect('/auth/login')\r\n  }\r\n}\r\n",
            "suspectedLines": [
              8,
              175,
              176,
              238,
              330,
              336
            ]
          },
          {
            "path": "lib/auth-dal.ts",
            "content": "/**\r\n * üõ°Ô∏è DATA ACCESS LAYER (DAL) - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Supabase 2025 :\r\n * - Centralise tous les auth checks server-side\r\n * - Utilise createServerClient pour s√©curit√© maximale\r\n * - Validation session syst√©matique avec getUser()\r\n * - Protection multi-couches (donn√©es + UI)\r\n */\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { cache } from 'react'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport type { User } from '@supabase/supabase-js'\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getUser() avec cache React et retry logic\r\n * Fonction centrale pour toute v√©rification auth server-side\r\n * Cache automatique pendant le cycle de rendu\r\n */\r\nexport const getUser = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // ‚úÖ NOUVEAU: Retry logic pour √©viter les race conditions apr√®s login\r\n  let retryCount = 0\r\n  const maxRetries = 3\r\n\r\n  while (retryCount <= maxRetries) {\r\n    try {\r\n      // ‚úÖ S√âCURIT√â: getUser() recommand√© vs getSession()\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('‚ùå [AUTH-DAL] Error getting user after retries:', error.message)\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] Error getting user, retry ${retryCount + 1}/${maxRetries}:`, error.message)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      if (!user) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('üîç [AUTH-DAL] No authenticated user found after retries')\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] No user found, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      console.log('‚úÖ [AUTH-DAL] User authenticated:', user.email)\r\n      return user\r\n    } catch (error) {\r\n      if (retryCount === maxRetries) {\r\n        console.error('‚ùå [AUTH-DAL] Exception in getUser after retries:', error)\r\n        return null\r\n      }\r\n      console.log(`‚è≥ [AUTH-DAL] Exception in getUser, retry ${retryCount + 1}/${maxRetries}:`, error)\r\n      retryCount++\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n  }\r\n\r\n  return null\r\n})\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getSession() avec validation\r\n * Pour les cas o√π on a besoin de la session compl√®te\r\n */\r\nexport const getSession = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.log('‚ùå [AUTH-DAL] Error getting session:', error.message)\r\n      return null\r\n    }\r\n\r\n    // ‚úÖ DOUBLE VALIDATION: V√©rifier que l'utilisateur existe vraiment\r\n    if (session?.user) {\r\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n      if (userError || !user) {\r\n        console.log('‚ö†Ô∏è [AUTH-DAL] Session exists but user validation failed')\r\n        return null\r\n      }\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Exception in getSession:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ PROTECTION MULTI-COUCHES: Auth check avec redirection automatique\r\n * Pour prot√©ger des pages compl√®tes\r\n */\r\nexport async function requireAuth(redirectTo: string = '/auth/login') {\r\n  const user = await getUser()\r\n\r\n  if (!user) {\r\n    console.log('üö´ [AUTH-DAL] Authentication required, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION R√îLE: V√©rification role-based access\r\n * Pour prot√©ger selon les r√¥les utilisateur\r\n */\r\nexport async function requireRole(allowedRoles: string[], redirectTo: string = '/auth/unauthorized') {\r\n  const user = await requireAuth()\r\n\r\n  // TODO: R√©cup√©rer le r√¥le depuis la base de donn√©es ou metadata\r\n  // const userRole = user.user_metadata?.role || 'user'\r\n  const userRole = 'admin' // Placeholder - √† impl√©menter selon votre logique\r\n\r\n  if (!allowedRoles.includes(userRole)) {\r\n    console.log('üö´ [AUTH-DAL] Insufficient permissions. Required:', allowedRoles, 'Got:', userRole)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return { user, role: userRole }\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION GUEST: S'assurer que l'utilisateur n'est PAS connect√©\r\n * Pour les pages comme login/signup\r\n */\r\nexport async function requireGuest(redirectTo: string = '/dashboard') {\r\n  const user = await getUser()\r\n\r\n  if (user) {\r\n    // TODO: D√©terminer redirection selon le r√¥le\r\n    console.log('üîÑ [AUTH-DAL] User already authenticated, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * ‚úÖ NOUVEAU: R√©cup√©ration profil utilisateur complet avec r√¥le\r\n * Retourne le user Supabase + profil app avec r√¥le\r\n */\r\nexport const getUserProfile = cache(async () => {\r\n  const supabaseUser = await getUser()\r\n\r\n  if (!supabaseUser) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    // ‚úÖ R√©cup√©rer le profil complet depuis la table users\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(supabaseUser.id)\r\n\r\n    if (!userResult.success || !userResult.data) {\r\n      console.log('‚ö†Ô∏è [AUTH-DAL] Supabase user exists but no profile found in users table:', supabaseUser.email)\r\n      return null\r\n    }\r\n\r\n    const userProfile = userResult.data\r\n\r\n    console.log('‚úÖ [AUTH-DAL] Complete user profile loaded:', {\r\n      email: userProfile.email,\r\n      role: userProfile.role,\r\n      id: userProfile.id\r\n    })\r\n\r\n    return {\r\n      supabaseUser,\r\n      profile: userProfile\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error loading user profile:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: D√©terminer dashboard selon le r√¥le\r\n */\r\nexport function getDashboardPath(_role: string): string {\r\n  switch (role) {\r\n    case 'admin':\r\n      return '/admin/dashboard'\r\n    case 'gestionnaire':\r\n      return '/gestionnaire/dashboard'\r\n    case 'prestataire':\r\n      return '/prestataire/dashboard'\r\n    case 'locataire':\r\n      return '/locataire/dashboard'\r\n    default:\r\n      return '/admin/dashboard' // Fallback\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: V√©rification auth sans redirection\r\n * Pour les composants qui s'adaptent selon l'√©tat auth\r\n */\r\nexport async function checkAuth() {\r\n  const user = await getUser()\r\n  const session = await getSession()\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: Server Action pour invalidation session\r\n * Peut √™tre utilis√© dans les Server Actions de d√©connexion\r\n */\r\nexport async function invalidateAuth() {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    await supabase.auth.signOut()\r\n    console.log('‚úÖ [AUTH-DAL] Session invalidated successfully')\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error invalidating session:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ OPTIMISATION: Type-safe auth state pour TypeScript\r\n */\r\nexport type AuthState = {\r\n  isAuthenticated: boolean\r\n  user: User | null\r\n  session: unknown | null\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: Helper pour Server Components\r\n * R√©cup√®re l'√©tat auth complet de mani√®re optimis√©e\r\n */\r\nexport async function getAuthState(): Promise<AuthState> {\r\n  const [user, session] = await Promise.all([\r\n    getUser(),\r\n    getSession()\r\n  ])\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n",
            "suspectedLines": [
              112,
              131,
              147
            ]
          },
          {
            "path": "app/auth/login/login-form.tsx",
            "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { useState, useActionState } from \"react\"\r\nimport { useFormStatus } from \"react-dom\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\r\nimport { Eye, EyeOff, Mail } from \"lucide-react\"\r\nimport { loginAction } from \"@/app/actions/auth-actions\"\r\n\r\n/**\r\n * üöÄ COMPOSANT CLIENT - LoginForm (Server Actions 2025)\r\n * Utilise les Server Actions pour authentification server-side s√©curis√©e\r\n */\r\n\r\n// Composant pour afficher le bouton de soumission avec √©tat\r\nfunction SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      className=\"w-full bg-primary hover:bg-secondary text-primary-foreground\"\r\n      disabled={pending}\r\n    >\r\n      {pending ? \"Connexion...\" : \"Se connecter\"}\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function LoginForm() {\r\n  const [showPassword, setShowPassword] = useState(false)\r\n  const [resendLoading, setResendLoading] = useState(false)\r\n  const [resendSuccess, setResendSuccess] = useState(false)\r\n  const [email, setEmail] = useState(\"\")\r\n\r\n  // ‚úÖ 2025: useActionState pour gestion √©tat Server Action\r\n  const [state, formAction] = useActionState(loginAction, { success: true })\r\n\r\n  // ‚úÖ LEGACY: Fonction de renvoi email (utilise ancien syst√®me pour compatibilit√©)\r\n  const handleResendConfirmation = async () => {\r\n    if (!email) {\r\n      return\r\n    }\r\n\r\n    setResendLoading(true)\r\n    setResendSuccess(false)\r\n\r\n    try {\r\n      // TODO: Migrer vers Server Action\r\n      console.log('üìß [LOGIN-FORM] Resending confirmation for:', email)\r\n      await new Promise(resolve => setTimeout(resolve, 2000))\r\n      setResendSuccess(true)\r\n    } catch (error) {\r\n      console.error('Erreur lors du renvoi de confirmation:', error)\r\n    } finally {\r\n      setResendLoading(false)\r\n    }\r\n  }\r\n\r\n  // ‚úÖ 2025: Afficher le bouton de renvoi si erreur email non confirm√©\r\n  const shouldShowResend = !state.success && state.error?.includes('confirmer votre email')\r\n\r\n  return (\r\n    <form action={formAction} className=\"space-y-4\">\r\n      {/* ‚úÖ 2025: Affichage erreurs depuis Server Action */}\r\n      {!state.success && state.error && (\r\n        <Alert variant=\"destructive\">\r\n          <AlertDescription>{state.error}</AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {resendSuccess && (\r\n        <Alert className=\"border-green-200 bg-green-50\">\r\n          <Mail className=\"h-4 w-4 text-green-600\" />\r\n          <AlertDescription className=\"text-green-800\">\r\n            Email de confirmation renvoy√© avec succ√®s ! V√©rifiez votre bo√Æte de r√©ception.\r\n          </AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {/* ‚úÖ 2025: Bouton renvoi conditionnel bas√© sur erreur Server Action */}\r\n      {shouldShowResend && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3\">\r\n          <div className=\"text-sm text-blue-800\">\r\n            <strong>Email non confirm√© ?</strong>\r\n          </div>\r\n          <p className=\"text-sm text-blue-700\">\r\n            Si vous n&apos;avez pas re√ßu l&apos;email de confirmation, vous pouvez le renvoyer.\r\n          </p>\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleResendConfirmation}\r\n            disabled={resendLoading}\r\n            className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\r\n          >\r\n            {resendLoading ? \"Envoi en cours...\" : \"Renvoyer l'email de confirmation\"}\r\n          </Button>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\" className=\"text-foreground\">\r\n          Adresse email\r\n        </Label>\r\n        <Input\r\n          id=\"email\"\r\n          name=\"email\"\r\n          type=\"email\"\r\n          placeholder=\"votre@email.com\"\r\n          value={email}\r\n          onChange={(e) => setEmail(e.target.value)}\r\n          className=\"bg-input border-border\"\r\n          required\r\n        />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"password\" className=\"text-foreground\">\r\n          Mot de passe\r\n        </Label>\r\n        <div className=\"relative\">\r\n          <Input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={showPassword ? \"text\" : \"password\"}\r\n            placeholder=\"Votre mot de passe\"\r\n            className=\"bg-input border-border pr-10\"\r\n            required\r\n          />\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n            onClick={() => setShowPassword(!showPassword)}\r\n          >\r\n            {showPassword ? (\r\n              <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\r\n            ) : (\r\n              <Eye className=\"h-4 w-4 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ‚úÖ 2025: Bouton avec √©tat Server Action */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\n",
            "suspectedLines": []
          },
          {
            "path": "middleware.ts",
            "content": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nimport { createServerClient } from '@supabase/ssr'\r\n\r\n/**\r\n * üõ°Ô∏è MIDDLEWARE AUTHENTIFICATION R√âELLE - SEIDO APP (Best Practices 2025)\r\n *\r\n * Conform√©ment aux recommandations officielles Next.js/Supabase :\r\n * - Authentification r√©elle avec supabase.auth.getUser()\r\n * - Rafra√Æchissement automatique des tokens\r\n * - Redirections serveur pour s√©curit√© optimale\r\n * - Centralis√© pour √©viter conflits avec AuthGuard client\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl\r\n\r\n  // Routes publiques (accessibles sans authentification)\r\n  const publicRoutes = [\r\n    '/auth/login',\r\n    '/auth/signup',\r\n    '/auth/signup-success',\r\n    '/auth/reset-password',\r\n    '/auth/update-password',\r\n    '/auth/callback',\r\n    '/auth/unauthorized',\r\n    '/'\r\n  ]\r\n\r\n  // Si route publique, laisser passer directement\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Routes prot√©g√©es - authentification r√©elle requise\r\n  const protectedPrefixes = ['/admin', '/gestionnaire', '/locataire', '/prestataire']\r\n  const isProtectedRoute = protectedPrefixes.some(prefix => pathname.startsWith(prefix))\r\n\r\n  if (isProtectedRoute) {\r\n    let response = NextResponse.next()\r\n\r\n    // ‚úÖ PATTERN OFFICIEL SUPABASE: Cr√©er client serveur pour middleware\r\n    const supabase = createServerClient(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return request.cookies.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              request.cookies.set(name, value)\r\n            )\r\n            response = NextResponse.next({\r\n              request: {\r\n                headers: request.headers,\r\n              },\r\n            })\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              response.cookies.set(name, value, options)\r\n            )\r\n          },\r\n        },\r\n      }\r\n    )\r\n\r\n    try {\r\n      // ‚úÖ AUTHENTIFICATION R√âELLE: V√©rifier et rafra√Æchir la session\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error || !user || !user.email_confirmed_at) {\r\n        console.log('üö´ [MIDDLEWARE] Authentication failed:', error?.message || 'No confirmed user')\r\n        return NextResponse.redirect(new URL('/auth/login?reason=session_expired', request.url))\r\n      }\r\n\r\n      console.log('‚úÖ [MIDDLEWARE] User authenticated:', user.id)\r\n\r\n      // Optionnel: V√©rification basique des r√¥les par URL\r\n      const roleFromPath = pathname.split('/')[1] // admin, gestionnaire, etc.\r\n      if (roleFromPath && ['admin', 'gestionnaire', 'locataire', 'prestataire'].includes(roleFromPath)) {\r\n        // La v√©rification d√©taill√©e des r√¥les se fera dans les Server Components avec DAL\r\n        console.log(`üîç [MIDDLEWARE] Access to ${roleFromPath} section - detailed role check in Server Component`)\r\n      }\r\n\r\n      return response\r\n\r\n    } catch (middlewareError) {\r\n      console.error('‚ùå [MIDDLEWARE] Authentication error:', middlewareError)\r\n      return NextResponse.redirect(new URL('/auth/login?reason=auth_error', request.url))\r\n    }\r\n  }\r\n\r\n  // Routes syst√®me/API ‚Üí laisser passer\r\n  return NextResponse.next()\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public files (public folder)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n}\r\n",
            "suspectedLines": [
              73,
              89
            ]
          }
        ],
        "previousAttempts": []
      },
      "fixApplied": {
        "success": true,
        "correction": {
          "description": "Fixed Server Action redirect by restructuring async flow",
          "filesModified": [
            {
              "path": "app/actions/auth-actions.ts",
              "changes": "Added missing redirect(dashboardPath) call outside try/catch block following Next.js 15 Server Action best practices",
              "backup": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\backups\\auth-actions.ts.backup"
            }
          ],
          "confidence": "high"
        }
      },
      "testResult": {
        "passed": false,
        "duration": 0
      },
      "artifacts": {
        "screenshots": [
          "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png"
        ],
        "logs": [],
        "diffs": []
      }
    },
    {
      "cycleNumber": 1,
      "startTime": "2025-09-30T10:57:47.454Z",
      "endTime": "2025-09-30T10:57:47.480Z",
      "duration": 26,
      "errorContext": {
        "testId": "auto-heal-login-1759229818815",
        "testName": "login-admin-auto-heal",
        "userRole": "admin",
        "error": {
          "type": "redirect",
          "message": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================",
          "stack": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================\n    at C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing\\demo-login-test.spec.ts:62:22",
          "step": "waitForURL",
          "timestamp": "2025-09-30T10:57:47.452Z"
        },
        "state": {
          "url": "http://localhost:3000/auth/login",
          "expectedUrl": "/admin/dashboard",
          "screenshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png",
          "domSnapshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\dom-snapshot.html",
          "networkLogs": [],
          "consoleLogs": []
        },
        "sourceFiles": [
          {
            "path": "app/actions/auth-actions.ts",
            "content": "/**\r\n * üöÄ SERVER ACTIONS - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Server Actions :\r\n * - Authentification server-side s√©curis√©e\r\n * - Validation c√¥t√© serveur syst√©matique\r\n * - Gestion erreurs appropri√©e\r\n * - Redirections s√©curis√©es avec redirect()\r\n */\r\n\r\n'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { requireGuest, invalidateAuth, getDashboardPath } from '@/lib/auth-dal'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport { z } from 'zod'\r\n\r\n// ‚úÖ VALIDATION: Schemas Zod pour s√©curit√© server-side\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string().min(1, 'Mot de passe requis')\r\n})\r\n\r\nconst SignupSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string()\r\n    .min(8, 'Au moins 8 caract√®res')\r\n    .regex(/[A-Z]/, 'Une majuscule requise')\r\n    .regex(/[a-z]/, 'Une minuscule requise')\r\n    .regex(/\\d/, 'Un chiffre requis'),\r\n  firstName: z.string().min(1, 'Pr√©nom requis').trim(),\r\n  lastName: z.string().min(1, 'Nom requis').trim(),\r\n  phone: z.string().optional(),\r\n  acceptTerms: z.boolean().refine(val => val === true, 'Acceptation des conditions requise')\r\n})\r\n\r\nconst ResetPasswordSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis')\r\n})\r\n\r\n// ‚úÖ TYPES: Return types pour actions\r\ntype AuthActionResult = {\r\n  success: boolean\r\n  error?: string\r\n  data?: {\r\n    message?: string\r\n    email?: string\r\n    [key: string]: unknown\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Connexion utilisateur\r\n */\r\nexport async function loginAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [LOGIN-ACTION] Starting server-side login...')\r\n\r\n  // ‚úÖ PATTERN OFFICIEL NEXT.JS 15: Gestion d'erreur AVANT le try/catch principal\r\n  try {\r\n    await requireGuest()\r\n  } catch {\r\n    // Utilisateur d√©j√† connect√© - retourner succ√®s\r\n    console.log('üîÑ [LOGIN-ACTION] User already authenticated')\r\n    return { success: true, data: { message: 'Already authenticated' } }\r\n  }\r\n\r\n  // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n  let validatedData\r\n  try {\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string\r\n    }\r\n    validatedData = LoginSchema.parse(rawData)\r\n    console.log('üìù [LOGIN-ACTION] Data validated for:', validatedData.email)\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n    return { success: false, error: 'Donn√©es invalides' }\r\n  }\r\n\r\n  // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n  const supabase = await createServerSupabaseClient()\r\n  const { data, error } = await supabase.auth.signInWithPassword({\r\n    email: validatedData.email,\r\n    password: validatedData.password\r\n  })\r\n\r\n  if (error) {\r\n    console.log('‚ùå [LOGIN-ACTION] Authentication failed:', error.message)\r\n\r\n    // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n    if (error.message.includes('Invalid login credentials')) {\r\n      return { success: false, error: 'Email ou mot de passe incorrect' }\r\n    }\r\n    if (error.message.includes('Email not confirmed')) {\r\n      return { success: false, error: 'Veuillez confirmer votre email avant de vous connecter' }\r\n    }\r\n    return { success: false, error: 'Erreur de connexion : ' + error.message }\r\n  }\r\n\r\n  if (!data.user) {\r\n    return { success: false, error: 'Erreur de connexion inattendue' }\r\n  }\r\n\r\n  console.log('‚úÖ [LOGIN-ACTION] User authenticated:', data.user.email)\r\n\r\n  // ‚úÖ NOUVEAU: Attendre que la session soit bien √©tablie c√¥t√© serveur\r\n  console.log('‚è≥ [LOGIN-ACTION] Waiting for server-side session to be established...')\r\n\r\n  // Cr√©er un nouveau client server pour v√©rifier la session\r\n  const sessionSupabase = await createServerSupabaseClient()\r\n  let sessionEstablished = false\r\n  let retryCount = 0\r\n  const maxRetries = 5\r\n\r\n  while (!sessionEstablished && retryCount < maxRetries) {\r\n    try {\r\n      const { data: sessionCheck, error: sessionError } = await sessionSupabase.auth.getUser()\r\n\r\n      if (!sessionError && sessionCheck.user && sessionCheck.user.id === data.user.id) {\r\n        console.log('‚úÖ [LOGIN-ACTION] Server-side session confirmed')\r\n        sessionEstablished = true\r\n      } else {\r\n        console.log(`‚è≥ [LOGIN-ACTION] Session not ready, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n\r\n        if (retryCount < maxRetries) {\r\n          // Attendre un peu avant de retry\r\n          await new Promise(resolve => setTimeout(resolve, 200))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(`‚è≥ [LOGIN-ACTION] Session check error, retry ${retryCount + 1}/${maxRetries}:`, error instanceof Error ? error.message : String(error))\r\n      retryCount++\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 200))\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!sessionEstablished) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Session not established after retries, proceeding anyway')\r\n  }\r\n\r\n  // ‚úÖ CACHE: Invalider le cache selon les bonnes pratiques\r\n  revalidatePath('/', 'layout')\r\n\r\n  // ‚úÖ D√âTERMINER REDIRECTION: Selon le r√¥le utilisateur\r\n  let dashboardPath = '/admin/dashboard' // Fallback par d√©faut\r\n\r\n  try {\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(data.user.id)\r\n\r\n    if (userResult.success && userResult.data && userResult.data.role) {\r\n      dashboardPath = getDashboardPath(userResult.data.role)\r\n      console.log('üîÑ [LOGIN-ACTION] Redirecting to role-specific dashboard:', {\r\n        role: userResult.data.role,\r\n        dashboard: dashboardPath,\r\n        sessionEstablished\r\n      })\r\n    } else {\r\n      console.log('‚ö†Ô∏è [LOGIN-ACTION] No role found, using default dashboard')\r\n    }\r\n  } catch (error) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Error determining role, using fallback:', error)\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Inscription utilisateur\r\n */\r\nexport async function signupAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [SIGNUP-ACTION] Starting server-side signup...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string,\r\n      firstName: formData.get('firstName') as string,\r\n      lastName: formData.get('lastName') as string,\r\n      phone: formData.get('phone') as string || undefined,\r\n      acceptTerms: formData.get('acceptTerms') === 'true'\r\n    }\r\n\r\n    const validatedData = SignupSchema.parse(rawData)\r\n    console.log('üìù [SIGNUP-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email: validatedData.email,\r\n      password: validatedData._password,\r\n      options: {\r\n        data: {\r\n          first_name: validatedData.firstName,\r\n          last_name: validatedData.lastName,\r\n          phone: validatedData.phone,\r\n          full_name: `${validatedData.firstName} ${validatedData.lastName}`\r\n        }\r\n      }\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [SIGNUP-ACTION] Signup failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User already registered')) {\r\n        return { success: false, error: 'Un compte existe d√©j√† avec cette adresse email' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de la cr√©ation du compte : ' + error.message }\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Erreur de cr√©ation de compte inattendue' }\r\n    }\r\n\r\n    console.log('‚úÖ [SIGNUP-ACTION] User created:', data.user.email)\r\n\r\n    // ‚úÖ CACHE: Invalider le cache des donn√©es auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de confirmation email\r\n    console.log('üìß [SIGNUP-ACTION] Redirecting to email confirmation page')\r\n    redirect('/auth/signup-success?email=' + encodeURIComponent(validatedData.email))\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [SIGNUP-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de la cr√©ation du compte' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: R√©initialisation mot de passe\r\n */\r\nexport async function resetPasswordAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [RESET-PASSWORD-ACTION] Starting server-side reset...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string\r\n    }\r\n\r\n    const validatedData = ResetPasswordSchema.parse(rawData)\r\n    console.log('üìù [RESET-PASSWORD-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { error } = await supabase.auth.resetPasswordForEmail(validatedData.email, {\r\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/update-password`\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [RESET-PASSWORD-ACTION] Reset failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User not found')) {\r\n        return { success: false, error: 'Aucun compte associ√© √† cette adresse email' }\r\n      }\r\n      if (error.message.includes('Email rate limit')) {\r\n        return { success: false, error: 'Trop de tentatives. Veuillez patienter avant de r√©essayer.' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de l\\'envoi de l\\'email : ' + error.message }\r\n    }\r\n\r\n    console.log('‚úÖ [RESET-PASSWORD-ACTION] Reset email sent to:', validatedData.email)\r\n\r\n    // ‚úÖ SUCC√àS: Retourner succ√®s sans redirection\r\n    return {\r\n      success: true,\r\n      data: {\r\n        message: 'Email de r√©initialisation envoy√© avec succ√®s',\r\n        email: validatedData.email\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [RESET-PASSWORD-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de l\\'envoi de l\\'email' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: D√©connexion utilisateur\r\n */\r\nexport async function logoutAction(): Promise<never> {\r\n  console.log('üöÄ [LOGOUT-ACTION] Starting server-side logout...')\r\n\r\n  try {\r\n    // ‚úÖ AUTHENTIFICATION: Invalider session\r\n    await invalidateAuth()\r\n\r\n    console.log('‚úÖ [LOGOUT-ACTION] User logged out successfully')\r\n\r\n    // ‚úÖ CACHE: Invalider tout le cache auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de connexion\r\n    redirect('/auth/login')\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [LOGOUT-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ FALLBACK: Redirection m√™me en cas d'erreur\r\n    redirect('/auth/login')\r\n  }\r\n}\r\n",
            "suspectedLines": [
              8,
              236,
              328,
              334
            ]
          },
          {
            "path": "lib/auth-dal.ts",
            "content": "/**\r\n * üõ°Ô∏è DATA ACCESS LAYER (DAL) - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Supabase 2025 :\r\n * - Centralise tous les auth checks server-side\r\n * - Utilise createServerClient pour s√©curit√© maximale\r\n * - Validation session syst√©matique avec getUser()\r\n * - Protection multi-couches (donn√©es + UI)\r\n */\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { cache } from 'react'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport type { User } from '@supabase/supabase-js'\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getUser() avec cache React et retry logic\r\n * Fonction centrale pour toute v√©rification auth server-side\r\n * Cache automatique pendant le cycle de rendu\r\n */\r\nexport const getUser = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // ‚úÖ NOUVEAU: Retry logic pour √©viter les race conditions apr√®s login\r\n  let retryCount = 0\r\n  const maxRetries = 3\r\n\r\n  while (retryCount <= maxRetries) {\r\n    try {\r\n      // ‚úÖ S√âCURIT√â: getUser() recommand√© vs getSession()\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('‚ùå [AUTH-DAL] Error getting user after retries:', error.message)\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] Error getting user, retry ${retryCount + 1}/${maxRetries}:`, error.message)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      if (!user) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('üîç [AUTH-DAL] No authenticated user found after retries')\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] No user found, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      console.log('‚úÖ [AUTH-DAL] User authenticated:', user.email)\r\n      return user\r\n    } catch (error) {\r\n      if (retryCount === maxRetries) {\r\n        console.error('‚ùå [AUTH-DAL] Exception in getUser after retries:', error)\r\n        return null\r\n      }\r\n      console.log(`‚è≥ [AUTH-DAL] Exception in getUser, retry ${retryCount + 1}/${maxRetries}:`, error)\r\n      retryCount++\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n  }\r\n\r\n  return null\r\n})\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getSession() avec validation\r\n * Pour les cas o√π on a besoin de la session compl√®te\r\n */\r\nexport const getSession = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.log('‚ùå [AUTH-DAL] Error getting session:', error.message)\r\n      return null\r\n    }\r\n\r\n    // ‚úÖ DOUBLE VALIDATION: V√©rifier que l'utilisateur existe vraiment\r\n    if (session?.user) {\r\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n      if (userError || !user) {\r\n        console.log('‚ö†Ô∏è [AUTH-DAL] Session exists but user validation failed')\r\n        return null\r\n      }\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Exception in getSession:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ PROTECTION MULTI-COUCHES: Auth check avec redirection automatique\r\n * Pour prot√©ger des pages compl√®tes\r\n */\r\nexport async function requireAuth(redirectTo: string = '/auth/login') {\r\n  const user = await getUser()\r\n\r\n  if (!user) {\r\n    console.log('üö´ [AUTH-DAL] Authentication required, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION R√îLE: V√©rification role-based access\r\n * Pour prot√©ger selon les r√¥les utilisateur\r\n */\r\nexport async function requireRole(allowedRoles: string[], redirectTo: string = '/auth/unauthorized') {\r\n  const user = await requireAuth()\r\n\r\n  // TODO: R√©cup√©rer le r√¥le depuis la base de donn√©es ou metadata\r\n  // const userRole = user.user_metadata?.role || 'user'\r\n  const userRole = 'admin' // Placeholder - √† impl√©menter selon votre logique\r\n\r\n  if (!allowedRoles.includes(userRole)) {\r\n    console.log('üö´ [AUTH-DAL] Insufficient permissions. Required:', allowedRoles, 'Got:', userRole)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return { user, role: userRole }\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION GUEST: S'assurer que l'utilisateur n'est PAS connect√©\r\n * Pour les pages comme login/signup\r\n */\r\nexport async function requireGuest(redirectTo: string = '/dashboard') {\r\n  const user = await getUser()\r\n\r\n  if (user) {\r\n    // TODO: D√©terminer redirection selon le r√¥le\r\n    console.log('üîÑ [AUTH-DAL] User already authenticated, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * ‚úÖ NOUVEAU: R√©cup√©ration profil utilisateur complet avec r√¥le\r\n * Retourne le user Supabase + profil app avec r√¥le\r\n */\r\nexport const getUserProfile = cache(async () => {\r\n  const supabaseUser = await getUser()\r\n\r\n  if (!supabaseUser) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    // ‚úÖ R√©cup√©rer le profil complet depuis la table users\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(supabaseUser.id)\r\n\r\n    if (!userResult.success || !userResult.data) {\r\n      console.log('‚ö†Ô∏è [AUTH-DAL] Supabase user exists but no profile found in users table:', supabaseUser.email)\r\n      return null\r\n    }\r\n\r\n    const userProfile = userResult.data\r\n\r\n    console.log('‚úÖ [AUTH-DAL] Complete user profile loaded:', {\r\n      email: userProfile.email,\r\n      role: userProfile.role,\r\n      id: userProfile.id\r\n    })\r\n\r\n    return {\r\n      supabaseUser,\r\n      profile: userProfile\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error loading user profile:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: D√©terminer dashboard selon le r√¥le\r\n */\r\nexport function getDashboardPath(_role: string): string {\r\n  switch (role) {\r\n    case 'admin':\r\n      return '/admin/dashboard'\r\n    case 'gestionnaire':\r\n      return '/gestionnaire/dashboard'\r\n    case 'prestataire':\r\n      return '/prestataire/dashboard'\r\n    case 'locataire':\r\n      return '/locataire/dashboard'\r\n    default:\r\n      return '/admin/dashboard' // Fallback\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: V√©rification auth sans redirection\r\n * Pour les composants qui s'adaptent selon l'√©tat auth\r\n */\r\nexport async function checkAuth() {\r\n  const user = await getUser()\r\n  const session = await getSession()\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: Server Action pour invalidation session\r\n * Peut √™tre utilis√© dans les Server Actions de d√©connexion\r\n */\r\nexport async function invalidateAuth() {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    await supabase.auth.signOut()\r\n    console.log('‚úÖ [AUTH-DAL] Session invalidated successfully')\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error invalidating session:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ OPTIMISATION: Type-safe auth state pour TypeScript\r\n */\r\nexport type AuthState = {\r\n  isAuthenticated: boolean\r\n  user: User | null\r\n  session: unknown | null\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: Helper pour Server Components\r\n * R√©cup√®re l'√©tat auth complet de mani√®re optimis√©e\r\n */\r\nexport async function getAuthState(): Promise<AuthState> {\r\n  const [user, session] = await Promise.all([\r\n    getUser(),\r\n    getSession()\r\n  ])\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n",
            "suspectedLines": [
              112,
              131,
              147
            ]
          },
          {
            "path": "app/auth/login/login-form.tsx",
            "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { useState, useActionState } from \"react\"\r\nimport { useFormStatus } from \"react-dom\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\r\nimport { Eye, EyeOff, Mail } from \"lucide-react\"\r\nimport { loginAction } from \"@/app/actions/auth-actions\"\r\n\r\n/**\r\n * üöÄ COMPOSANT CLIENT - LoginForm (Server Actions 2025)\r\n * Utilise les Server Actions pour authentification server-side s√©curis√©e\r\n */\r\n\r\n// Composant pour afficher le bouton de soumission avec √©tat\r\nfunction SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      className=\"w-full bg-primary hover:bg-secondary text-primary-foreground\"\r\n      disabled={pending}\r\n    >\r\n      {pending ? \"Connexion...\" : \"Se connecter\"}\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function LoginForm() {\r\n  const [showPassword, setShowPassword] = useState(false)\r\n  const [resendLoading, setResendLoading] = useState(false)\r\n  const [resendSuccess, setResendSuccess] = useState(false)\r\n  const [email, setEmail] = useState(\"\")\r\n\r\n  // ‚úÖ 2025: useActionState pour gestion √©tat Server Action\r\n  const [state, formAction] = useActionState(loginAction, { success: true })\r\n\r\n  // ‚úÖ LEGACY: Fonction de renvoi email (utilise ancien syst√®me pour compatibilit√©)\r\n  const handleResendConfirmation = async () => {\r\n    if (!email) {\r\n      return\r\n    }\r\n\r\n    setResendLoading(true)\r\n    setResendSuccess(false)\r\n\r\n    try {\r\n      // TODO: Migrer vers Server Action\r\n      console.log('üìß [LOGIN-FORM] Resending confirmation for:', email)\r\n      await new Promise(resolve => setTimeout(resolve, 2000))\r\n      setResendSuccess(true)\r\n    } catch (error) {\r\n      console.error('Erreur lors du renvoi de confirmation:', error)\r\n    } finally {\r\n      setResendLoading(false)\r\n    }\r\n  }\r\n\r\n  // ‚úÖ 2025: Afficher le bouton de renvoi si erreur email non confirm√©\r\n  const shouldShowResend = !state.success && state.error?.includes('confirmer votre email')\r\n\r\n  return (\r\n    <form action={formAction} className=\"space-y-4\">\r\n      {/* ‚úÖ 2025: Affichage erreurs depuis Server Action */}\r\n      {!state.success && state.error && (\r\n        <Alert variant=\"destructive\">\r\n          <AlertDescription>{state.error}</AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {resendSuccess && (\r\n        <Alert className=\"border-green-200 bg-green-50\">\r\n          <Mail className=\"h-4 w-4 text-green-600\" />\r\n          <AlertDescription className=\"text-green-800\">\r\n            Email de confirmation renvoy√© avec succ√®s ! V√©rifiez votre bo√Æte de r√©ception.\r\n          </AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {/* ‚úÖ 2025: Bouton renvoi conditionnel bas√© sur erreur Server Action */}\r\n      {shouldShowResend && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3\">\r\n          <div className=\"text-sm text-blue-800\">\r\n            <strong>Email non confirm√© ?</strong>\r\n          </div>\r\n          <p className=\"text-sm text-blue-700\">\r\n            Si vous n&apos;avez pas re√ßu l&apos;email de confirmation, vous pouvez le renvoyer.\r\n          </p>\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleResendConfirmation}\r\n            disabled={resendLoading}\r\n            className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\r\n          >\r\n            {resendLoading ? \"Envoi en cours...\" : \"Renvoyer l'email de confirmation\"}\r\n          </Button>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\" className=\"text-foreground\">\r\n          Adresse email\r\n        </Label>\r\n        <Input\r\n          id=\"email\"\r\n          name=\"email\"\r\n          type=\"email\"\r\n          placeholder=\"votre@email.com\"\r\n          value={email}\r\n          onChange={(e) => setEmail(e.target.value)}\r\n          className=\"bg-input border-border\"\r\n          required\r\n        />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"password\" className=\"text-foreground\">\r\n          Mot de passe\r\n        </Label>\r\n        <div className=\"relative\">\r\n          <Input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={showPassword ? \"text\" : \"password\"}\r\n            placeholder=\"Votre mot de passe\"\r\n            className=\"bg-input border-border pr-10\"\r\n            required\r\n          />\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n            onClick={() => setShowPassword(!showPassword)}\r\n          >\r\n            {showPassword ? (\r\n              <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\r\n            ) : (\r\n              <Eye className=\"h-4 w-4 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ‚úÖ 2025: Bouton avec √©tat Server Action */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\n",
            "suspectedLines": []
          },
          {
            "path": "middleware.ts",
            "content": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nimport { createServerClient } from '@supabase/ssr'\r\n\r\n/**\r\n * üõ°Ô∏è MIDDLEWARE AUTHENTIFICATION R√âELLE - SEIDO APP (Best Practices 2025)\r\n *\r\n * Conform√©ment aux recommandations officielles Next.js/Supabase :\r\n * - Authentification r√©elle avec supabase.auth.getUser()\r\n * - Rafra√Æchissement automatique des tokens\r\n * - Redirections serveur pour s√©curit√© optimale\r\n * - Centralis√© pour √©viter conflits avec AuthGuard client\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl\r\n\r\n  // Routes publiques (accessibles sans authentification)\r\n  const publicRoutes = [\r\n    '/auth/login',\r\n    '/auth/signup',\r\n    '/auth/signup-success',\r\n    '/auth/reset-password',\r\n    '/auth/update-password',\r\n    '/auth/callback',\r\n    '/auth/unauthorized',\r\n    '/'\r\n  ]\r\n\r\n  // Si route publique, laisser passer directement\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Routes prot√©g√©es - authentification r√©elle requise\r\n  const protectedPrefixes = ['/admin', '/gestionnaire', '/locataire', '/prestataire']\r\n  const isProtectedRoute = protectedPrefixes.some(prefix => pathname.startsWith(prefix))\r\n\r\n  if (isProtectedRoute) {\r\n    let response = NextResponse.next()\r\n\r\n    // ‚úÖ PATTERN OFFICIEL SUPABASE: Cr√©er client serveur pour middleware\r\n    const supabase = createServerClient(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return request.cookies.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              request.cookies.set(name, value)\r\n            )\r\n            response = NextResponse.next({\r\n              request: {\r\n                headers: request.headers,\r\n              },\r\n            })\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              response.cookies.set(name, value, options)\r\n            )\r\n          },\r\n        },\r\n      }\r\n    )\r\n\r\n    try {\r\n      // ‚úÖ AUTHENTIFICATION R√âELLE: V√©rifier et rafra√Æchir la session\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error || !user || !user.email_confirmed_at) {\r\n        console.log('üö´ [MIDDLEWARE] Authentication failed:', error?.message || 'No confirmed user')\r\n        return NextResponse.redirect(new URL('/auth/login?reason=session_expired', request.url))\r\n      }\r\n\r\n      console.log('‚úÖ [MIDDLEWARE] User authenticated:', user.id)\r\n\r\n      // Optionnel: V√©rification basique des r√¥les par URL\r\n      const roleFromPath = pathname.split('/')[1] // admin, gestionnaire, etc.\r\n      if (roleFromPath && ['admin', 'gestionnaire', 'locataire', 'prestataire'].includes(roleFromPath)) {\r\n        // La v√©rification d√©taill√©e des r√¥les se fera dans les Server Components avec DAL\r\n        console.log(`üîç [MIDDLEWARE] Access to ${roleFromPath} section - detailed role check in Server Component`)\r\n      }\r\n\r\n      return response\r\n\r\n    } catch (middlewareError) {\r\n      console.error('‚ùå [MIDDLEWARE] Authentication error:', middlewareError)\r\n      return NextResponse.redirect(new URL('/auth/login?reason=auth_error', request.url))\r\n    }\r\n  }\r\n\r\n  // Routes syst√®me/API ‚Üí laisser passer\r\n  return NextResponse.next()\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public files (public folder)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n}\r\n",
            "suspectedLines": [
              73,
              89
            ]
          }
        ],
        "previousAttempts": []
      },
      "fixApplied": {
        "success": false,
        "error": "Could not detect redirect issue in auth-actions.ts",
        "nextSteps": [
          "Check if redirect() is being called correctly",
          "Verify dashboard path is correct",
          "Check middleware configuration"
        ]
      },
      "testResult": {
        "passed": false,
        "error": "Could not detect redirect issue in auth-actions.ts",
        "duration": 0
      },
      "artifacts": {
        "screenshots": [],
        "logs": [],
        "diffs": []
      }
    },
    {
      "cycleNumber": 2,
      "startTime": "2025-09-30T10:57:50.481Z",
      "endTime": "2025-09-30T10:57:50.509Z",
      "duration": 28,
      "errorContext": {
        "testId": "auto-heal-login-1759229818815",
        "testName": "login-admin-auto-heal",
        "userRole": "admin",
        "error": {
          "type": "redirect",
          "message": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================",
          "stack": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================\n    at C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing\\demo-login-test.spec.ts:62:22",
          "step": "waitForURL",
          "timestamp": "2025-09-30T10:57:47.452Z"
        },
        "state": {
          "url": "http://localhost:3000/auth/login",
          "expectedUrl": "/admin/dashboard",
          "screenshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png",
          "domSnapshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\dom-snapshot.html",
          "networkLogs": [],
          "consoleLogs": []
        },
        "sourceFiles": [
          {
            "path": "app/actions/auth-actions.ts",
            "content": "/**\r\n * üöÄ SERVER ACTIONS - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Server Actions :\r\n * - Authentification server-side s√©curis√©e\r\n * - Validation c√¥t√© serveur syst√©matique\r\n * - Gestion erreurs appropri√©e\r\n * - Redirections s√©curis√©es avec redirect()\r\n */\r\n\r\n'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { requireGuest, invalidateAuth, getDashboardPath } from '@/lib/auth-dal'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport { z } from 'zod'\r\n\r\n// ‚úÖ VALIDATION: Schemas Zod pour s√©curit√© server-side\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string().min(1, 'Mot de passe requis')\r\n})\r\n\r\nconst SignupSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string()\r\n    .min(8, 'Au moins 8 caract√®res')\r\n    .regex(/[A-Z]/, 'Une majuscule requise')\r\n    .regex(/[a-z]/, 'Une minuscule requise')\r\n    .regex(/\\d/, 'Un chiffre requis'),\r\n  firstName: z.string().min(1, 'Pr√©nom requis').trim(),\r\n  lastName: z.string().min(1, 'Nom requis').trim(),\r\n  phone: z.string().optional(),\r\n  acceptTerms: z.boolean().refine(val => val === true, 'Acceptation des conditions requise')\r\n})\r\n\r\nconst ResetPasswordSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis')\r\n})\r\n\r\n// ‚úÖ TYPES: Return types pour actions\r\ntype AuthActionResult = {\r\n  success: boolean\r\n  error?: string\r\n  data?: {\r\n    message?: string\r\n    email?: string\r\n    [key: string]: unknown\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Connexion utilisateur\r\n */\r\nexport async function loginAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [LOGIN-ACTION] Starting server-side login...')\r\n\r\n  // ‚úÖ PATTERN OFFICIEL NEXT.JS 15: Gestion d'erreur AVANT le try/catch principal\r\n  try {\r\n    await requireGuest()\r\n  } catch {\r\n    // Utilisateur d√©j√† connect√© - retourner succ√®s\r\n    console.log('üîÑ [LOGIN-ACTION] User already authenticated')\r\n    return { success: true, data: { message: 'Already authenticated' } }\r\n  }\r\n\r\n  // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n  let validatedData\r\n  try {\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string\r\n    }\r\n    validatedData = LoginSchema.parse(rawData)\r\n    console.log('üìù [LOGIN-ACTION] Data validated for:', validatedData.email)\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n    return { success: false, error: 'Donn√©es invalides' }\r\n  }\r\n\r\n  // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n  const supabase = await createServerSupabaseClient()\r\n  const { data, error } = await supabase.auth.signInWithPassword({\r\n    email: validatedData.email,\r\n    password: validatedData.password\r\n  })\r\n\r\n  if (error) {\r\n    console.log('‚ùå [LOGIN-ACTION] Authentication failed:', error.message)\r\n\r\n    // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n    if (error.message.includes('Invalid login credentials')) {\r\n      return { success: false, error: 'Email ou mot de passe incorrect' }\r\n    }\r\n    if (error.message.includes('Email not confirmed')) {\r\n      return { success: false, error: 'Veuillez confirmer votre email avant de vous connecter' }\r\n    }\r\n    return { success: false, error: 'Erreur de connexion : ' + error.message }\r\n  }\r\n\r\n  if (!data.user) {\r\n    return { success: false, error: 'Erreur de connexion inattendue' }\r\n  }\r\n\r\n  console.log('‚úÖ [LOGIN-ACTION] User authenticated:', data.user.email)\r\n\r\n  // ‚úÖ NOUVEAU: Attendre que la session soit bien √©tablie c√¥t√© serveur\r\n  console.log('‚è≥ [LOGIN-ACTION] Waiting for server-side session to be established...')\r\n\r\n  // Cr√©er un nouveau client server pour v√©rifier la session\r\n  const sessionSupabase = await createServerSupabaseClient()\r\n  let sessionEstablished = false\r\n  let retryCount = 0\r\n  const maxRetries = 5\r\n\r\n  while (!sessionEstablished && retryCount < maxRetries) {\r\n    try {\r\n      const { data: sessionCheck, error: sessionError } = await sessionSupabase.auth.getUser()\r\n\r\n      if (!sessionError && sessionCheck.user && sessionCheck.user.id === data.user.id) {\r\n        console.log('‚úÖ [LOGIN-ACTION] Server-side session confirmed')\r\n        sessionEstablished = true\r\n      } else {\r\n        console.log(`‚è≥ [LOGIN-ACTION] Session not ready, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n\r\n        if (retryCount < maxRetries) {\r\n          // Attendre un peu avant de retry\r\n          await new Promise(resolve => setTimeout(resolve, 200))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(`‚è≥ [LOGIN-ACTION] Session check error, retry ${retryCount + 1}/${maxRetries}:`, error instanceof Error ? error.message : String(error))\r\n      retryCount++\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 200))\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!sessionEstablished) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Session not established after retries, proceeding anyway')\r\n  }\r\n\r\n  // ‚úÖ CACHE: Invalider le cache selon les bonnes pratiques\r\n  revalidatePath('/', 'layout')\r\n\r\n  // ‚úÖ D√âTERMINER REDIRECTION: Selon le r√¥le utilisateur\r\n  let dashboardPath = '/admin/dashboard' // Fallback par d√©faut\r\n\r\n  try {\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(data.user.id)\r\n\r\n    if (userResult.success && userResult.data && userResult.data.role) {\r\n      dashboardPath = getDashboardPath(userResult.data.role)\r\n      console.log('üîÑ [LOGIN-ACTION] Redirecting to role-specific dashboard:', {\r\n        role: userResult.data.role,\r\n        dashboard: dashboardPath,\r\n        sessionEstablished\r\n      })\r\n    } else {\r\n      console.log('‚ö†Ô∏è [LOGIN-ACTION] No role found, using default dashboard')\r\n    }\r\n  } catch (error) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Error determining role, using fallback:', error)\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Inscription utilisateur\r\n */\r\nexport async function signupAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [SIGNUP-ACTION] Starting server-side signup...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string,\r\n      firstName: formData.get('firstName') as string,\r\n      lastName: formData.get('lastName') as string,\r\n      phone: formData.get('phone') as string || undefined,\r\n      acceptTerms: formData.get('acceptTerms') === 'true'\r\n    }\r\n\r\n    const validatedData = SignupSchema.parse(rawData)\r\n    console.log('üìù [SIGNUP-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email: validatedData.email,\r\n      password: validatedData._password,\r\n      options: {\r\n        data: {\r\n          first_name: validatedData.firstName,\r\n          last_name: validatedData.lastName,\r\n          phone: validatedData.phone,\r\n          full_name: `${validatedData.firstName} ${validatedData.lastName}`\r\n        }\r\n      }\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [SIGNUP-ACTION] Signup failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User already registered')) {\r\n        return { success: false, error: 'Un compte existe d√©j√† avec cette adresse email' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de la cr√©ation du compte : ' + error.message }\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Erreur de cr√©ation de compte inattendue' }\r\n    }\r\n\r\n    console.log('‚úÖ [SIGNUP-ACTION] User created:', data.user.email)\r\n\r\n    // ‚úÖ CACHE: Invalider le cache des donn√©es auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de confirmation email\r\n    console.log('üìß [SIGNUP-ACTION] Redirecting to email confirmation page')\r\n    redirect('/auth/signup-success?email=' + encodeURIComponent(validatedData.email))\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [SIGNUP-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de la cr√©ation du compte' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: R√©initialisation mot de passe\r\n */\r\nexport async function resetPasswordAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [RESET-PASSWORD-ACTION] Starting server-side reset...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string\r\n    }\r\n\r\n    const validatedData = ResetPasswordSchema.parse(rawData)\r\n    console.log('üìù [RESET-PASSWORD-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { error } = await supabase.auth.resetPasswordForEmail(validatedData.email, {\r\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/update-password`\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [RESET-PASSWORD-ACTION] Reset failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User not found')) {\r\n        return { success: false, error: 'Aucun compte associ√© √† cette adresse email' }\r\n      }\r\n      if (error.message.includes('Email rate limit')) {\r\n        return { success: false, error: 'Trop de tentatives. Veuillez patienter avant de r√©essayer.' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de l\\'envoi de l\\'email : ' + error.message }\r\n    }\r\n\r\n    console.log('‚úÖ [RESET-PASSWORD-ACTION] Reset email sent to:', validatedData.email)\r\n\r\n    // ‚úÖ SUCC√àS: Retourner succ√®s sans redirection\r\n    return {\r\n      success: true,\r\n      data: {\r\n        message: 'Email de r√©initialisation envoy√© avec succ√®s',\r\n        email: validatedData.email\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [RESET-PASSWORD-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de l\\'envoi de l\\'email' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: D√©connexion utilisateur\r\n */\r\nexport async function logoutAction(): Promise<never> {\r\n  console.log('üöÄ [LOGOUT-ACTION] Starting server-side logout...')\r\n\r\n  try {\r\n    // ‚úÖ AUTHENTIFICATION: Invalider session\r\n    await invalidateAuth()\r\n\r\n    console.log('‚úÖ [LOGOUT-ACTION] User logged out successfully')\r\n\r\n    // ‚úÖ CACHE: Invalider tout le cache auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de connexion\r\n    redirect('/auth/login')\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [LOGOUT-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ FALLBACK: Redirection m√™me en cas d'erreur\r\n    redirect('/auth/login')\r\n  }\r\n}\r\n",
            "suspectedLines": [
              8,
              236,
              328,
              334
            ]
          },
          {
            "path": "lib/auth-dal.ts",
            "content": "/**\r\n * üõ°Ô∏è DATA ACCESS LAYER (DAL) - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Supabase 2025 :\r\n * - Centralise tous les auth checks server-side\r\n * - Utilise createServerClient pour s√©curit√© maximale\r\n * - Validation session syst√©matique avec getUser()\r\n * - Protection multi-couches (donn√©es + UI)\r\n */\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { cache } from 'react'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport type { User } from '@supabase/supabase-js'\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getUser() avec cache React et retry logic\r\n * Fonction centrale pour toute v√©rification auth server-side\r\n * Cache automatique pendant le cycle de rendu\r\n */\r\nexport const getUser = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // ‚úÖ NOUVEAU: Retry logic pour √©viter les race conditions apr√®s login\r\n  let retryCount = 0\r\n  const maxRetries = 3\r\n\r\n  while (retryCount <= maxRetries) {\r\n    try {\r\n      // ‚úÖ S√âCURIT√â: getUser() recommand√© vs getSession()\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('‚ùå [AUTH-DAL] Error getting user after retries:', error.message)\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] Error getting user, retry ${retryCount + 1}/${maxRetries}:`, error.message)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      if (!user) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('üîç [AUTH-DAL] No authenticated user found after retries')\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] No user found, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      console.log('‚úÖ [AUTH-DAL] User authenticated:', user.email)\r\n      return user\r\n    } catch (error) {\r\n      if (retryCount === maxRetries) {\r\n        console.error('‚ùå [AUTH-DAL] Exception in getUser after retries:', error)\r\n        return null\r\n      }\r\n      console.log(`‚è≥ [AUTH-DAL] Exception in getUser, retry ${retryCount + 1}/${maxRetries}:`, error)\r\n      retryCount++\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n  }\r\n\r\n  return null\r\n})\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getSession() avec validation\r\n * Pour les cas o√π on a besoin de la session compl√®te\r\n */\r\nexport const getSession = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.log('‚ùå [AUTH-DAL] Error getting session:', error.message)\r\n      return null\r\n    }\r\n\r\n    // ‚úÖ DOUBLE VALIDATION: V√©rifier que l'utilisateur existe vraiment\r\n    if (session?.user) {\r\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n      if (userError || !user) {\r\n        console.log('‚ö†Ô∏è [AUTH-DAL] Session exists but user validation failed')\r\n        return null\r\n      }\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Exception in getSession:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ PROTECTION MULTI-COUCHES: Auth check avec redirection automatique\r\n * Pour prot√©ger des pages compl√®tes\r\n */\r\nexport async function requireAuth(redirectTo: string = '/auth/login') {\r\n  const user = await getUser()\r\n\r\n  if (!user) {\r\n    console.log('üö´ [AUTH-DAL] Authentication required, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION R√îLE: V√©rification role-based access\r\n * Pour prot√©ger selon les r√¥les utilisateur\r\n */\r\nexport async function requireRole(allowedRoles: string[], redirectTo: string = '/auth/unauthorized') {\r\n  const user = await requireAuth()\r\n\r\n  // TODO: R√©cup√©rer le r√¥le depuis la base de donn√©es ou metadata\r\n  // const userRole = user.user_metadata?.role || 'user'\r\n  const userRole = 'admin' // Placeholder - √† impl√©menter selon votre logique\r\n\r\n  if (!allowedRoles.includes(userRole)) {\r\n    console.log('üö´ [AUTH-DAL] Insufficient permissions. Required:', allowedRoles, 'Got:', userRole)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return { user, role: userRole }\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION GUEST: S'assurer que l'utilisateur n'est PAS connect√©\r\n * Pour les pages comme login/signup\r\n */\r\nexport async function requireGuest(redirectTo: string = '/dashboard') {\r\n  const user = await getUser()\r\n\r\n  if (user) {\r\n    // TODO: D√©terminer redirection selon le r√¥le\r\n    console.log('üîÑ [AUTH-DAL] User already authenticated, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * ‚úÖ NOUVEAU: R√©cup√©ration profil utilisateur complet avec r√¥le\r\n * Retourne le user Supabase + profil app avec r√¥le\r\n */\r\nexport const getUserProfile = cache(async () => {\r\n  const supabaseUser = await getUser()\r\n\r\n  if (!supabaseUser) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    // ‚úÖ R√©cup√©rer le profil complet depuis la table users\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(supabaseUser.id)\r\n\r\n    if (!userResult.success || !userResult.data) {\r\n      console.log('‚ö†Ô∏è [AUTH-DAL] Supabase user exists but no profile found in users table:', supabaseUser.email)\r\n      return null\r\n    }\r\n\r\n    const userProfile = userResult.data\r\n\r\n    console.log('‚úÖ [AUTH-DAL] Complete user profile loaded:', {\r\n      email: userProfile.email,\r\n      role: userProfile.role,\r\n      id: userProfile.id\r\n    })\r\n\r\n    return {\r\n      supabaseUser,\r\n      profile: userProfile\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error loading user profile:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: D√©terminer dashboard selon le r√¥le\r\n */\r\nexport function getDashboardPath(_role: string): string {\r\n  switch (role) {\r\n    case 'admin':\r\n      return '/admin/dashboard'\r\n    case 'gestionnaire':\r\n      return '/gestionnaire/dashboard'\r\n    case 'prestataire':\r\n      return '/prestataire/dashboard'\r\n    case 'locataire':\r\n      return '/locataire/dashboard'\r\n    default:\r\n      return '/admin/dashboard' // Fallback\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: V√©rification auth sans redirection\r\n * Pour les composants qui s'adaptent selon l'√©tat auth\r\n */\r\nexport async function checkAuth() {\r\n  const user = await getUser()\r\n  const session = await getSession()\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: Server Action pour invalidation session\r\n * Peut √™tre utilis√© dans les Server Actions de d√©connexion\r\n */\r\nexport async function invalidateAuth() {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    await supabase.auth.signOut()\r\n    console.log('‚úÖ [AUTH-DAL] Session invalidated successfully')\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error invalidating session:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ OPTIMISATION: Type-safe auth state pour TypeScript\r\n */\r\nexport type AuthState = {\r\n  isAuthenticated: boolean\r\n  user: User | null\r\n  session: unknown | null\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: Helper pour Server Components\r\n * R√©cup√®re l'√©tat auth complet de mani√®re optimis√©e\r\n */\r\nexport async function getAuthState(): Promise<AuthState> {\r\n  const [user, session] = await Promise.all([\r\n    getUser(),\r\n    getSession()\r\n  ])\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n",
            "suspectedLines": [
              112,
              131,
              147
            ]
          },
          {
            "path": "app/auth/login/login-form.tsx",
            "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { useState, useActionState } from \"react\"\r\nimport { useFormStatus } from \"react-dom\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\r\nimport { Eye, EyeOff, Mail } from \"lucide-react\"\r\nimport { loginAction } from \"@/app/actions/auth-actions\"\r\n\r\n/**\r\n * üöÄ COMPOSANT CLIENT - LoginForm (Server Actions 2025)\r\n * Utilise les Server Actions pour authentification server-side s√©curis√©e\r\n */\r\n\r\n// Composant pour afficher le bouton de soumission avec √©tat\r\nfunction SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      className=\"w-full bg-primary hover:bg-secondary text-primary-foreground\"\r\n      disabled={pending}\r\n    >\r\n      {pending ? \"Connexion...\" : \"Se connecter\"}\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function LoginForm() {\r\n  const [showPassword, setShowPassword] = useState(false)\r\n  const [resendLoading, setResendLoading] = useState(false)\r\n  const [resendSuccess, setResendSuccess] = useState(false)\r\n  const [email, setEmail] = useState(\"\")\r\n\r\n  // ‚úÖ 2025: useActionState pour gestion √©tat Server Action\r\n  const [state, formAction] = useActionState(loginAction, { success: true })\r\n\r\n  // ‚úÖ LEGACY: Fonction de renvoi email (utilise ancien syst√®me pour compatibilit√©)\r\n  const handleResendConfirmation = async () => {\r\n    if (!email) {\r\n      return\r\n    }\r\n\r\n    setResendLoading(true)\r\n    setResendSuccess(false)\r\n\r\n    try {\r\n      // TODO: Migrer vers Server Action\r\n      console.log('üìß [LOGIN-FORM] Resending confirmation for:', email)\r\n      await new Promise(resolve => setTimeout(resolve, 2000))\r\n      setResendSuccess(true)\r\n    } catch (error) {\r\n      console.error('Erreur lors du renvoi de confirmation:', error)\r\n    } finally {\r\n      setResendLoading(false)\r\n    }\r\n  }\r\n\r\n  // ‚úÖ 2025: Afficher le bouton de renvoi si erreur email non confirm√©\r\n  const shouldShowResend = !state.success && state.error?.includes('confirmer votre email')\r\n\r\n  return (\r\n    <form action={formAction} className=\"space-y-4\">\r\n      {/* ‚úÖ 2025: Affichage erreurs depuis Server Action */}\r\n      {!state.success && state.error && (\r\n        <Alert variant=\"destructive\">\r\n          <AlertDescription>{state.error}</AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {resendSuccess && (\r\n        <Alert className=\"border-green-200 bg-green-50\">\r\n          <Mail className=\"h-4 w-4 text-green-600\" />\r\n          <AlertDescription className=\"text-green-800\">\r\n            Email de confirmation renvoy√© avec succ√®s ! V√©rifiez votre bo√Æte de r√©ception.\r\n          </AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {/* ‚úÖ 2025: Bouton renvoi conditionnel bas√© sur erreur Server Action */}\r\n      {shouldShowResend && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3\">\r\n          <div className=\"text-sm text-blue-800\">\r\n            <strong>Email non confirm√© ?</strong>\r\n          </div>\r\n          <p className=\"text-sm text-blue-700\">\r\n            Si vous n&apos;avez pas re√ßu l&apos;email de confirmation, vous pouvez le renvoyer.\r\n          </p>\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleResendConfirmation}\r\n            disabled={resendLoading}\r\n            className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\r\n          >\r\n            {resendLoading ? \"Envoi en cours...\" : \"Renvoyer l'email de confirmation\"}\r\n          </Button>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\" className=\"text-foreground\">\r\n          Adresse email\r\n        </Label>\r\n        <Input\r\n          id=\"email\"\r\n          name=\"email\"\r\n          type=\"email\"\r\n          placeholder=\"votre@email.com\"\r\n          value={email}\r\n          onChange={(e) => setEmail(e.target.value)}\r\n          className=\"bg-input border-border\"\r\n          required\r\n        />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"password\" className=\"text-foreground\">\r\n          Mot de passe\r\n        </Label>\r\n        <div className=\"relative\">\r\n          <Input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={showPassword ? \"text\" : \"password\"}\r\n            placeholder=\"Votre mot de passe\"\r\n            className=\"bg-input border-border pr-10\"\r\n            required\r\n          />\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n            onClick={() => setShowPassword(!showPassword)}\r\n          >\r\n            {showPassword ? (\r\n              <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\r\n            ) : (\r\n              <Eye className=\"h-4 w-4 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ‚úÖ 2025: Bouton avec √©tat Server Action */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\n",
            "suspectedLines": []
          },
          {
            "path": "middleware.ts",
            "content": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nimport { createServerClient } from '@supabase/ssr'\r\n\r\n/**\r\n * üõ°Ô∏è MIDDLEWARE AUTHENTIFICATION R√âELLE - SEIDO APP (Best Practices 2025)\r\n *\r\n * Conform√©ment aux recommandations officielles Next.js/Supabase :\r\n * - Authentification r√©elle avec supabase.auth.getUser()\r\n * - Rafra√Æchissement automatique des tokens\r\n * - Redirections serveur pour s√©curit√© optimale\r\n * - Centralis√© pour √©viter conflits avec AuthGuard client\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl\r\n\r\n  // Routes publiques (accessibles sans authentification)\r\n  const publicRoutes = [\r\n    '/auth/login',\r\n    '/auth/signup',\r\n    '/auth/signup-success',\r\n    '/auth/reset-password',\r\n    '/auth/update-password',\r\n    '/auth/callback',\r\n    '/auth/unauthorized',\r\n    '/'\r\n  ]\r\n\r\n  // Si route publique, laisser passer directement\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Routes prot√©g√©es - authentification r√©elle requise\r\n  const protectedPrefixes = ['/admin', '/gestionnaire', '/locataire', '/prestataire']\r\n  const isProtectedRoute = protectedPrefixes.some(prefix => pathname.startsWith(prefix))\r\n\r\n  if (isProtectedRoute) {\r\n    let response = NextResponse.next()\r\n\r\n    // ‚úÖ PATTERN OFFICIEL SUPABASE: Cr√©er client serveur pour middleware\r\n    const supabase = createServerClient(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return request.cookies.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              request.cookies.set(name, value)\r\n            )\r\n            response = NextResponse.next({\r\n              request: {\r\n                headers: request.headers,\r\n              },\r\n            })\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              response.cookies.set(name, value, options)\r\n            )\r\n          },\r\n        },\r\n      }\r\n    )\r\n\r\n    try {\r\n      // ‚úÖ AUTHENTIFICATION R√âELLE: V√©rifier et rafra√Æchir la session\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error || !user || !user.email_confirmed_at) {\r\n        console.log('üö´ [MIDDLEWARE] Authentication failed:', error?.message || 'No confirmed user')\r\n        return NextResponse.redirect(new URL('/auth/login?reason=session_expired', request.url))\r\n      }\r\n\r\n      console.log('‚úÖ [MIDDLEWARE] User authenticated:', user.id)\r\n\r\n      // Optionnel: V√©rification basique des r√¥les par URL\r\n      const roleFromPath = pathname.split('/')[1] // admin, gestionnaire, etc.\r\n      if (roleFromPath && ['admin', 'gestionnaire', 'locataire', 'prestataire'].includes(roleFromPath)) {\r\n        // La v√©rification d√©taill√©e des r√¥les se fera dans les Server Components avec DAL\r\n        console.log(`üîç [MIDDLEWARE] Access to ${roleFromPath} section - detailed role check in Server Component`)\r\n      }\r\n\r\n      return response\r\n\r\n    } catch (middlewareError) {\r\n      console.error('‚ùå [MIDDLEWARE] Authentication error:', middlewareError)\r\n      return NextResponse.redirect(new URL('/auth/login?reason=auth_error', request.url))\r\n    }\r\n  }\r\n\r\n  // Routes syst√®me/API ‚Üí laisser passer\r\n  return NextResponse.next()\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public files (public folder)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n}\r\n",
            "suspectedLines": [
              73,
              89
            ]
          }
        ],
        "previousAttempts": []
      },
      "fixApplied": {
        "success": false,
        "error": "Could not detect redirect issue in auth-actions.ts",
        "nextSteps": [
          "Check if redirect() is being called correctly",
          "Verify dashboard path is correct",
          "Check middleware configuration"
        ]
      },
      "testResult": {
        "passed": false,
        "error": "Could not detect redirect issue in auth-actions.ts",
        "duration": 0
      },
      "artifacts": {
        "screenshots": [],
        "logs": [],
        "diffs": []
      }
    },
    {
      "cycleNumber": 3,
      "startTime": "2025-09-30T10:57:53.524Z",
      "endTime": "2025-09-30T10:57:53.545Z",
      "duration": 21,
      "errorContext": {
        "testId": "auto-heal-login-1759229818815",
        "testName": "login-admin-auto-heal",
        "userRole": "admin",
        "error": {
          "type": "redirect",
          "message": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================",
          "stack": "page.waitForURL: Timeout 10000ms exceeded.\n=========================== logs ===========================\nwaiting for navigation to \"**/admin/dashboard**\" until \"load\"\n============================================================\n    at C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing\\demo-login-test.spec.ts:62:22",
          "step": "waitForURL",
          "timestamp": "2025-09-30T10:57:47.452Z"
        },
        "state": {
          "url": "http://localhost:3000/auth/login",
          "expectedUrl": "/admin/dashboard",
          "screenshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\error-screenshot.png",
          "domSnapshot": "C:\\Users\\arthu\\Desktop\\Coding\\Seido-app\\docs\\refacto\\Tests\\auto-healing-artifacts\\auto-heal-login-1759229818815\\dom-snapshot.html",
          "networkLogs": [],
          "consoleLogs": []
        },
        "sourceFiles": [
          {
            "path": "app/actions/auth-actions.ts",
            "content": "/**\r\n * üöÄ SERVER ACTIONS - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Server Actions :\r\n * - Authentification server-side s√©curis√©e\r\n * - Validation c√¥t√© serveur syst√©matique\r\n * - Gestion erreurs appropri√©e\r\n * - Redirections s√©curis√©es avec redirect()\r\n */\r\n\r\n'use server'\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { revalidatePath } from 'next/cache'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { requireGuest, invalidateAuth, getDashboardPath } from '@/lib/auth-dal'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport { z } from 'zod'\r\n\r\n// ‚úÖ VALIDATION: Schemas Zod pour s√©curit√© server-side\r\nconst LoginSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string().min(1, 'Mot de passe requis')\r\n})\r\n\r\nconst SignupSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis'),\r\n  password: z.string()\r\n    .min(8, 'Au moins 8 caract√®res')\r\n    .regex(/[A-Z]/, 'Une majuscule requise')\r\n    .regex(/[a-z]/, 'Une minuscule requise')\r\n    .regex(/\\d/, 'Un chiffre requis'),\r\n  firstName: z.string().min(1, 'Pr√©nom requis').trim(),\r\n  lastName: z.string().min(1, 'Nom requis').trim(),\r\n  phone: z.string().optional(),\r\n  acceptTerms: z.boolean().refine(val => val === true, 'Acceptation des conditions requise')\r\n})\r\n\r\nconst ResetPasswordSchema = z.object({\r\n  email: z.string().email('Email invalide').min(1, 'Email requis')\r\n})\r\n\r\n// ‚úÖ TYPES: Return types pour actions\r\ntype AuthActionResult = {\r\n  success: boolean\r\n  error?: string\r\n  data?: {\r\n    message?: string\r\n    email?: string\r\n    [key: string]: unknown\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Connexion utilisateur\r\n */\r\nexport async function loginAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [LOGIN-ACTION] Starting server-side login...')\r\n\r\n  // ‚úÖ PATTERN OFFICIEL NEXT.JS 15: Gestion d'erreur AVANT le try/catch principal\r\n  try {\r\n    await requireGuest()\r\n  } catch {\r\n    // Utilisateur d√©j√† connect√© - retourner succ√®s\r\n    console.log('üîÑ [LOGIN-ACTION] User already authenticated')\r\n    return { success: true, data: { message: 'Already authenticated' } }\r\n  }\r\n\r\n  // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n  let validatedData\r\n  try {\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string\r\n    }\r\n    validatedData = LoginSchema.parse(rawData)\r\n    console.log('üìù [LOGIN-ACTION] Data validated for:', validatedData.email)\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n    return { success: false, error: 'Donn√©es invalides' }\r\n  }\r\n\r\n  // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n  const supabase = await createServerSupabaseClient()\r\n  const { data, error } = await supabase.auth.signInWithPassword({\r\n    email: validatedData.email,\r\n    password: validatedData.password\r\n  })\r\n\r\n  if (error) {\r\n    console.log('‚ùå [LOGIN-ACTION] Authentication failed:', error.message)\r\n\r\n    // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n    if (error.message.includes('Invalid login credentials')) {\r\n      return { success: false, error: 'Email ou mot de passe incorrect' }\r\n    }\r\n    if (error.message.includes('Email not confirmed')) {\r\n      return { success: false, error: 'Veuillez confirmer votre email avant de vous connecter' }\r\n    }\r\n    return { success: false, error: 'Erreur de connexion : ' + error.message }\r\n  }\r\n\r\n  if (!data.user) {\r\n    return { success: false, error: 'Erreur de connexion inattendue' }\r\n  }\r\n\r\n  console.log('‚úÖ [LOGIN-ACTION] User authenticated:', data.user.email)\r\n\r\n  // ‚úÖ NOUVEAU: Attendre que la session soit bien √©tablie c√¥t√© serveur\r\n  console.log('‚è≥ [LOGIN-ACTION] Waiting for server-side session to be established...')\r\n\r\n  // Cr√©er un nouveau client server pour v√©rifier la session\r\n  const sessionSupabase = await createServerSupabaseClient()\r\n  let sessionEstablished = false\r\n  let retryCount = 0\r\n  const maxRetries = 5\r\n\r\n  while (!sessionEstablished && retryCount < maxRetries) {\r\n    try {\r\n      const { data: sessionCheck, error: sessionError } = await sessionSupabase.auth.getUser()\r\n\r\n      if (!sessionError && sessionCheck.user && sessionCheck.user.id === data.user.id) {\r\n        console.log('‚úÖ [LOGIN-ACTION] Server-side session confirmed')\r\n        sessionEstablished = true\r\n      } else {\r\n        console.log(`‚è≥ [LOGIN-ACTION] Session not ready, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n\r\n        if (retryCount < maxRetries) {\r\n          // Attendre un peu avant de retry\r\n          await new Promise(resolve => setTimeout(resolve, 200))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(`‚è≥ [LOGIN-ACTION] Session check error, retry ${retryCount + 1}/${maxRetries}:`, error instanceof Error ? error.message : String(error))\r\n      retryCount++\r\n\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 200))\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!sessionEstablished) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Session not established after retries, proceeding anyway')\r\n  }\r\n\r\n  // ‚úÖ CACHE: Invalider le cache selon les bonnes pratiques\r\n  revalidatePath('/', 'layout')\r\n\r\n  // ‚úÖ D√âTERMINER REDIRECTION: Selon le r√¥le utilisateur\r\n  let dashboardPath = '/admin/dashboard' // Fallback par d√©faut\r\n\r\n  try {\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(data.user.id)\r\n\r\n    if (userResult.success && userResult.data && userResult.data.role) {\r\n      dashboardPath = getDashboardPath(userResult.data.role)\r\n      console.log('üîÑ [LOGIN-ACTION] Redirecting to role-specific dashboard:', {\r\n        role: userResult.data.role,\r\n        dashboard: dashboardPath,\r\n        sessionEstablished\r\n      })\r\n    } else {\r\n      console.log('‚ö†Ô∏è [LOGIN-ACTION] No role found, using default dashboard')\r\n    }\r\n  } catch (error) {\r\n    console.log('‚ö†Ô∏è [LOGIN-ACTION] Error determining role, using fallback:', error)\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: Inscription utilisateur\r\n */\r\nexport async function signupAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [SIGNUP-ACTION] Starting server-side signup...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string,\r\n      password: formData.get('password') as string,\r\n      firstName: formData.get('firstName') as string,\r\n      lastName: formData.get('lastName') as string,\r\n      phone: formData.get('phone') as string || undefined,\r\n      acceptTerms: formData.get('acceptTerms') === 'true'\r\n    }\r\n\r\n    const validatedData = SignupSchema.parse(rawData)\r\n    console.log('üìù [SIGNUP-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email: validatedData.email,\r\n      password: validatedData._password,\r\n      options: {\r\n        data: {\r\n          first_name: validatedData.firstName,\r\n          last_name: validatedData.lastName,\r\n          phone: validatedData.phone,\r\n          full_name: `${validatedData.firstName} ${validatedData.lastName}`\r\n        }\r\n      }\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [SIGNUP-ACTION] Signup failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User already registered')) {\r\n        return { success: false, error: 'Un compte existe d√©j√† avec cette adresse email' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de la cr√©ation du compte : ' + error.message }\r\n    }\r\n\r\n    if (!data.user) {\r\n      return { success: false, error: 'Erreur de cr√©ation de compte inattendue' }\r\n    }\r\n\r\n    console.log('‚úÖ [SIGNUP-ACTION] User created:', data.user.email)\r\n\r\n    // ‚úÖ CACHE: Invalider le cache des donn√©es auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de confirmation email\r\n    console.log('üìß [SIGNUP-ACTION] Redirecting to email confirmation page')\r\n    redirect('/auth/signup-success?email=' + encodeURIComponent(validatedData.email))\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [SIGNUP-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de la cr√©ation du compte' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: R√©initialisation mot de passe\r\n */\r\nexport async function resetPasswordAction(prevState: AuthActionResult, formData: FormData): Promise<AuthActionResult> {\r\n  console.log('üöÄ [RESET-PASSWORD-ACTION] Starting server-side reset...')\r\n\r\n  try {\r\n    // ‚úÖ S√âCURIT√â: V√©rifier que l'utilisateur n'est pas d√©j√† connect√©\r\n    await requireGuest()\r\n\r\n    // ‚úÖ VALIDATION: Parser et valider les donn√©es\r\n    const rawData = {\r\n      email: formData.get('email') as string\r\n    }\r\n\r\n    const validatedData = ResetPasswordSchema.parse(rawData)\r\n    console.log('üìù [RESET-PASSWORD-ACTION] Data validated for:', validatedData.email)\r\n\r\n    // ‚úÖ AUTHENTIFICATION: Utiliser client server Supabase\r\n    const supabase = await createServerSupabaseClient()\r\n    const { error } = await supabase.auth.resetPasswordForEmail(validatedData.email, {\r\n      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/update-password`\r\n    })\r\n\r\n    if (error) {\r\n      console.log('‚ùå [RESET-PASSWORD-ACTION] Reset failed:', error.message)\r\n\r\n      // ‚úÖ GESTION ERREURS: Messages utilisateur-friendly\r\n      if (error.message.includes('User not found')) {\r\n        return { success: false, error: 'Aucun compte associ√© √† cette adresse email' }\r\n      }\r\n      if (error.message.includes('Email rate limit')) {\r\n        return { success: false, error: 'Trop de tentatives. Veuillez patienter avant de r√©essayer.' }\r\n      }\r\n      return { success: false, error: 'Erreur lors de l\\'envoi de l\\'email : ' + error.message }\r\n    }\r\n\r\n    console.log('‚úÖ [RESET-PASSWORD-ACTION] Reset email sent to:', validatedData.email)\r\n\r\n    // ‚úÖ SUCC√àS: Retourner succ√®s sans redirection\r\n    return {\r\n      success: true,\r\n      data: {\r\n        message: 'Email de r√©initialisation envoy√© avec succ√®s',\r\n        email: validatedData.email\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [RESET-PASSWORD-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ GESTION: Erreurs de validation Zod\r\n    if (error instanceof z.ZodError) {\r\n      const firstError = error.errors[0]\r\n      return { success: false, error: firstError.message }\r\n    }\r\n\r\n    return { success: false, error: 'Une erreur est survenue lors de l\\'envoi de l\\'email' }\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ SERVER ACTION: D√©connexion utilisateur\r\n */\r\nexport async function logoutAction(): Promise<never> {\r\n  console.log('üöÄ [LOGOUT-ACTION] Starting server-side logout...')\r\n\r\n  try {\r\n    // ‚úÖ AUTHENTIFICATION: Invalider session\r\n    await invalidateAuth()\r\n\r\n    console.log('‚úÖ [LOGOUT-ACTION] User logged out successfully')\r\n\r\n    // ‚úÖ CACHE: Invalider tout le cache auth\r\n    revalidatePath('/', 'layout')\r\n\r\n    // ‚úÖ REDIRECTION: Vers page de connexion\r\n    redirect('/auth/login')\r\n\r\n  } catch (error) {\r\n    console.error('‚ùå [LOGOUT-ACTION] Exception:', error)\r\n\r\n    // ‚úÖ FALLBACK: Redirection m√™me en cas d'erreur\r\n    redirect('/auth/login')\r\n  }\r\n}\r\n",
            "suspectedLines": [
              8,
              236,
              328,
              334
            ]
          },
          {
            "path": "lib/auth-dal.ts",
            "content": "/**\r\n * üõ°Ô∏è DATA ACCESS LAYER (DAL) - AUTHENTICATION\r\n *\r\n * Conform√©ment aux bonnes pratiques Next.js 15 / Supabase 2025 :\r\n * - Centralise tous les auth checks server-side\r\n * - Utilise createServerClient pour s√©curit√© maximale\r\n * - Validation session syst√©matique avec getUser()\r\n * - Protection multi-couches (donn√©es + UI)\r\n */\r\n\r\nimport { redirect } from 'next/navigation'\r\nimport { cache } from 'react'\r\nimport { createServerSupabaseClient } from '@/lib/services/core/supabase-client'\r\nimport { createServerUserService } from '@/lib/services'\r\nimport type { User } from '@supabase/supabase-js'\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getUser() avec cache React et retry logic\r\n * Fonction centrale pour toute v√©rification auth server-side\r\n * Cache automatique pendant le cycle de rendu\r\n */\r\nexport const getUser = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  // ‚úÖ NOUVEAU: Retry logic pour √©viter les race conditions apr√®s login\r\n  let retryCount = 0\r\n  const maxRetries = 3\r\n\r\n  while (retryCount <= maxRetries) {\r\n    try {\r\n      // ‚úÖ S√âCURIT√â: getUser() recommand√© vs getSession()\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('‚ùå [AUTH-DAL] Error getting user after retries:', error.message)\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] Error getting user, retry ${retryCount + 1}/${maxRetries}:`, error.message)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      if (!user) {\r\n        if (retryCount === maxRetries) {\r\n          console.log('üîç [AUTH-DAL] No authenticated user found after retries')\r\n          return null\r\n        }\r\n        console.log(`‚è≥ [AUTH-DAL] No user found, retry ${retryCount + 1}/${maxRetries}`)\r\n        retryCount++\r\n        await new Promise(resolve => setTimeout(resolve, 100))\r\n        continue\r\n      }\r\n\r\n      console.log('‚úÖ [AUTH-DAL] User authenticated:', user.email)\r\n      return user\r\n    } catch (error) {\r\n      if (retryCount === maxRetries) {\r\n        console.error('‚ùå [AUTH-DAL] Exception in getUser after retries:', error)\r\n        return null\r\n      }\r\n      console.log(`‚è≥ [AUTH-DAL] Exception in getUser, retry ${retryCount + 1}/${maxRetries}:`, error)\r\n      retryCount++\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n  }\r\n\r\n  return null\r\n})\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: getSession() avec validation\r\n * Pour les cas o√π on a besoin de la session compl√®te\r\n */\r\nexport const getSession = cache(async () => {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    const { data: { session }, error } = await supabase.auth.getSession()\r\n\r\n    if (error) {\r\n      console.log('‚ùå [AUTH-DAL] Error getting session:', error.message)\r\n      return null\r\n    }\r\n\r\n    // ‚úÖ DOUBLE VALIDATION: V√©rifier que l'utilisateur existe vraiment\r\n    if (session?.user) {\r\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\r\n      if (userError || !user) {\r\n        console.log('‚ö†Ô∏è [AUTH-DAL] Session exists but user validation failed')\r\n        return null\r\n      }\r\n    }\r\n\r\n    return session\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Exception in getSession:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ PROTECTION MULTI-COUCHES: Auth check avec redirection automatique\r\n * Pour prot√©ger des pages compl√®tes\r\n */\r\nexport async function requireAuth(redirectTo: string = '/auth/login') {\r\n  const user = await getUser()\r\n\r\n  if (!user) {\r\n    console.log('üö´ [AUTH-DAL] Authentication required, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return user\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION R√îLE: V√©rification role-based access\r\n * Pour prot√©ger selon les r√¥les utilisateur\r\n */\r\nexport async function requireRole(allowedRoles: string[], redirectTo: string = '/auth/unauthorized') {\r\n  const user = await requireAuth()\r\n\r\n  // TODO: R√©cup√©rer le r√¥le depuis la base de donn√©es ou metadata\r\n  // const userRole = user.user_metadata?.role || 'user'\r\n  const userRole = 'admin' // Placeholder - √† impl√©menter selon votre logique\r\n\r\n  if (!allowedRoles.includes(userRole)) {\r\n    console.log('üö´ [AUTH-DAL] Insufficient permissions. Required:', allowedRoles, 'Got:', userRole)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return { user, role: userRole }\r\n}\r\n\r\n/**\r\n * ‚úÖ PROTECTION GUEST: S'assurer que l'utilisateur n'est PAS connect√©\r\n * Pour les pages comme login/signup\r\n */\r\nexport async function requireGuest(redirectTo: string = '/dashboard') {\r\n  const user = await getUser()\r\n\r\n  if (user) {\r\n    // TODO: D√©terminer redirection selon le r√¥le\r\n    console.log('üîÑ [AUTH-DAL] User already authenticated, redirecting to:', redirectTo)\r\n    redirect(redirectTo)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * ‚úÖ NOUVEAU: R√©cup√©ration profil utilisateur complet avec r√¥le\r\n * Retourne le user Supabase + profil app avec r√¥le\r\n */\r\nexport const getUserProfile = cache(async () => {\r\n  const supabaseUser = await getUser()\r\n\r\n  if (!supabaseUser) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    // ‚úÖ R√©cup√©rer le profil complet depuis la table users\r\n    const userService = await createServerUserService()\r\n    const userResult = await userService.getByAuthUserId(supabaseUser.id)\r\n\r\n    if (!userResult.success || !userResult.data) {\r\n      console.log('‚ö†Ô∏è [AUTH-DAL] Supabase user exists but no profile found in users table:', supabaseUser.email)\r\n      return null\r\n    }\r\n\r\n    const userProfile = userResult.data\r\n\r\n    console.log('‚úÖ [AUTH-DAL] Complete user profile loaded:', {\r\n      email: userProfile.email,\r\n      role: userProfile.role,\r\n      id: userProfile.id\r\n    })\r\n\r\n    return {\r\n      supabaseUser,\r\n      profile: userProfile\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error loading user profile:', error)\r\n    return null\r\n  }\r\n})\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: D√©terminer dashboard selon le r√¥le\r\n */\r\nexport function getDashboardPath(_role: string): string {\r\n  switch (role) {\r\n    case 'admin':\r\n      return '/admin/dashboard'\r\n    case 'gestionnaire':\r\n      return '/gestionnaire/dashboard'\r\n    case 'prestataire':\r\n      return '/prestataire/dashboard'\r\n    case 'locataire':\r\n      return '/locataire/dashboard'\r\n    default:\r\n      return '/admin/dashboard' // Fallback\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: V√©rification auth sans redirection\r\n * Pour les composants qui s'adaptent selon l'√©tat auth\r\n */\r\nexport async function checkAuth() {\r\n  const user = await getUser()\r\n  const session = await getSession()\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ PATTERN 2025: Server Action pour invalidation session\r\n * Peut √™tre utilis√© dans les Server Actions de d√©connexion\r\n */\r\nexport async function invalidateAuth() {\r\n  const supabase = await createServerSupabaseClient()\r\n\r\n  try {\r\n    await supabase.auth.signOut()\r\n    console.log('‚úÖ [AUTH-DAL] Session invalidated successfully')\r\n  } catch (error) {\r\n    console.error('‚ùå [AUTH-DAL] Error invalidating session:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * ‚úÖ OPTIMISATION: Type-safe auth state pour TypeScript\r\n */\r\nexport type AuthState = {\r\n  isAuthenticated: boolean\r\n  user: User | null\r\n  session: unknown | null\r\n}\r\n\r\n/**\r\n * ‚úÖ UTILITAIRE: Helper pour Server Components\r\n * R√©cup√®re l'√©tat auth complet de mani√®re optimis√©e\r\n */\r\nexport async function getAuthState(): Promise<AuthState> {\r\n  const [user, session] = await Promise.all([\r\n    getUser(),\r\n    getSession()\r\n  ])\r\n\r\n  return {\r\n    isAuthenticated: !!user,\r\n    user,\r\n    session\r\n  }\r\n}\r\n",
            "suspectedLines": [
              112,
              131,
              147
            ]
          },
          {
            "path": "app/auth/login/login-form.tsx",
            "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { useState, useActionState } from \"react\"\r\nimport { useFormStatus } from \"react-dom\"\r\nimport { Button } from \"@/components/ui/button\"\r\nimport { Input } from \"@/components/ui/input\"\r\nimport { Label } from \"@/components/ui/label\"\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\"\r\nimport { Eye, EyeOff, Mail } from \"lucide-react\"\r\nimport { loginAction } from \"@/app/actions/auth-actions\"\r\n\r\n/**\r\n * üöÄ COMPOSANT CLIENT - LoginForm (Server Actions 2025)\r\n * Utilise les Server Actions pour authentification server-side s√©curis√©e\r\n */\r\n\r\n// Composant pour afficher le bouton de soumission avec √©tat\r\nfunction SubmitButton() {\r\n  const { pending } = useFormStatus()\r\n\r\n  return (\r\n    <Button\r\n      type=\"submit\"\r\n      className=\"w-full bg-primary hover:bg-secondary text-primary-foreground\"\r\n      disabled={pending}\r\n    >\r\n      {pending ? \"Connexion...\" : \"Se connecter\"}\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function LoginForm() {\r\n  const [showPassword, setShowPassword] = useState(false)\r\n  const [resendLoading, setResendLoading] = useState(false)\r\n  const [resendSuccess, setResendSuccess] = useState(false)\r\n  const [email, setEmail] = useState(\"\")\r\n\r\n  // ‚úÖ 2025: useActionState pour gestion √©tat Server Action\r\n  const [state, formAction] = useActionState(loginAction, { success: true })\r\n\r\n  // ‚úÖ LEGACY: Fonction de renvoi email (utilise ancien syst√®me pour compatibilit√©)\r\n  const handleResendConfirmation = async () => {\r\n    if (!email) {\r\n      return\r\n    }\r\n\r\n    setResendLoading(true)\r\n    setResendSuccess(false)\r\n\r\n    try {\r\n      // TODO: Migrer vers Server Action\r\n      console.log('üìß [LOGIN-FORM] Resending confirmation for:', email)\r\n      await new Promise(resolve => setTimeout(resolve, 2000))\r\n      setResendSuccess(true)\r\n    } catch (error) {\r\n      console.error('Erreur lors du renvoi de confirmation:', error)\r\n    } finally {\r\n      setResendLoading(false)\r\n    }\r\n  }\r\n\r\n  // ‚úÖ 2025: Afficher le bouton de renvoi si erreur email non confirm√©\r\n  const shouldShowResend = !state.success && state.error?.includes('confirmer votre email')\r\n\r\n  return (\r\n    <form action={formAction} className=\"space-y-4\">\r\n      {/* ‚úÖ 2025: Affichage erreurs depuis Server Action */}\r\n      {!state.success && state.error && (\r\n        <Alert variant=\"destructive\">\r\n          <AlertDescription>{state.error}</AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {resendSuccess && (\r\n        <Alert className=\"border-green-200 bg-green-50\">\r\n          <Mail className=\"h-4 w-4 text-green-600\" />\r\n          <AlertDescription className=\"text-green-800\">\r\n            Email de confirmation renvoy√© avec succ√®s ! V√©rifiez votre bo√Æte de r√©ception.\r\n          </AlertDescription>\r\n        </Alert>\r\n      )}\r\n\r\n      {/* ‚úÖ 2025: Bouton renvoi conditionnel bas√© sur erreur Server Action */}\r\n      {shouldShowResend && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 space-y-3\">\r\n          <div className=\"text-sm text-blue-800\">\r\n            <strong>Email non confirm√© ?</strong>\r\n          </div>\r\n          <p className=\"text-sm text-blue-700\">\r\n            Si vous n&apos;avez pas re√ßu l&apos;email de confirmation, vous pouvez le renvoyer.\r\n          </p>\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={handleResendConfirmation}\r\n            disabled={resendLoading}\r\n            className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\r\n          >\r\n            {resendLoading ? \"Envoi en cours...\" : \"Renvoyer l'email de confirmation\"}\r\n          </Button>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"email\" className=\"text-foreground\">\r\n          Adresse email\r\n        </Label>\r\n        <Input\r\n          id=\"email\"\r\n          name=\"email\"\r\n          type=\"email\"\r\n          placeholder=\"votre@email.com\"\r\n          value={email}\r\n          onChange={(e) => setEmail(e.target.value)}\r\n          className=\"bg-input border-border\"\r\n          required\r\n        />\r\n      </div>\r\n\r\n      <div className=\"space-y-2\">\r\n        <Label htmlFor=\"password\" className=\"text-foreground\">\r\n          Mot de passe\r\n        </Label>\r\n        <div className=\"relative\">\r\n          <Input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={showPassword ? \"text\" : \"password\"}\r\n            placeholder=\"Votre mot de passe\"\r\n            className=\"bg-input border-border pr-10\"\r\n            required\r\n          />\r\n          <Button\r\n            type=\"button\"\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            className=\"absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent\"\r\n            onClick={() => setShowPassword(!showPassword)}\r\n          >\r\n            {showPassword ? (\r\n              <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\r\n            ) : (\r\n              <Eye className=\"h-4 w-4 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* ‚úÖ 2025: Bouton avec √©tat Server Action */}\r\n      <SubmitButton />\r\n    </form>\r\n  )\r\n}\r\n",
            "suspectedLines": []
          },
          {
            "path": "middleware.ts",
            "content": "import { NextResponse } from 'next/server'\r\nimport type { NextRequest } from 'next/server'\r\nimport { createServerClient } from '@supabase/ssr'\r\n\r\n/**\r\n * üõ°Ô∏è MIDDLEWARE AUTHENTIFICATION R√âELLE - SEIDO APP (Best Practices 2025)\r\n *\r\n * Conform√©ment aux recommandations officielles Next.js/Supabase :\r\n * - Authentification r√©elle avec supabase.auth.getUser()\r\n * - Rafra√Æchissement automatique des tokens\r\n * - Redirections serveur pour s√©curit√© optimale\r\n * - Centralis√© pour √©viter conflits avec AuthGuard client\r\n */\r\nexport async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl\r\n\r\n  // Routes publiques (accessibles sans authentification)\r\n  const publicRoutes = [\r\n    '/auth/login',\r\n    '/auth/signup',\r\n    '/auth/signup-success',\r\n    '/auth/reset-password',\r\n    '/auth/update-password',\r\n    '/auth/callback',\r\n    '/auth/unauthorized',\r\n    '/'\r\n  ]\r\n\r\n  // Si route publique, laisser passer directement\r\n  if (publicRoutes.includes(pathname)) {\r\n    return NextResponse.next()\r\n  }\r\n\r\n  // Routes prot√©g√©es - authentification r√©elle requise\r\n  const protectedPrefixes = ['/admin', '/gestionnaire', '/locataire', '/prestataire']\r\n  const isProtectedRoute = protectedPrefixes.some(prefix => pathname.startsWith(prefix))\r\n\r\n  if (isProtectedRoute) {\r\n    let response = NextResponse.next()\r\n\r\n    // ‚úÖ PATTERN OFFICIEL SUPABASE: Cr√©er client serveur pour middleware\r\n    const supabase = createServerClient(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n      {\r\n        cookies: {\r\n          getAll() {\r\n            return request.cookies.getAll()\r\n          },\r\n          setAll(cookiesToSet) {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              request.cookies.set(name, value)\r\n            )\r\n            response = NextResponse.next({\r\n              request: {\r\n                headers: request.headers,\r\n              },\r\n            })\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              response.cookies.set(name, value, options)\r\n            )\r\n          },\r\n        },\r\n      }\r\n    )\r\n\r\n    try {\r\n      // ‚úÖ AUTHENTIFICATION R√âELLE: V√©rifier et rafra√Æchir la session\r\n      const { data: { user }, error } = await supabase.auth.getUser()\r\n\r\n      if (error || !user || !user.email_confirmed_at) {\r\n        console.log('üö´ [MIDDLEWARE] Authentication failed:', error?.message || 'No confirmed user')\r\n        return NextResponse.redirect(new URL('/auth/login?reason=session_expired', request.url))\r\n      }\r\n\r\n      console.log('‚úÖ [MIDDLEWARE] User authenticated:', user.id)\r\n\r\n      // Optionnel: V√©rification basique des r√¥les par URL\r\n      const roleFromPath = pathname.split('/')[1] // admin, gestionnaire, etc.\r\n      if (roleFromPath && ['admin', 'gestionnaire', 'locataire', 'prestataire'].includes(roleFromPath)) {\r\n        // La v√©rification d√©taill√©e des r√¥les se fera dans les Server Components avec DAL\r\n        console.log(`üîç [MIDDLEWARE] Access to ${roleFromPath} section - detailed role check in Server Component`)\r\n      }\r\n\r\n      return response\r\n\r\n    } catch (middlewareError) {\r\n      console.error('‚ùå [MIDDLEWARE] Authentication error:', middlewareError)\r\n      return NextResponse.redirect(new URL('/auth/login?reason=auth_error', request.url))\r\n    }\r\n  }\r\n\r\n  // Routes syst√®me/API ‚Üí laisser passer\r\n  return NextResponse.next()\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public files (public folder)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n}\r\n",
            "suspectedLines": [
              73,
              89
            ]
          }
        ],
        "previousAttempts": []
      },
      "fixApplied": {
        "success": false,
        "error": "Could not detect redirect issue in auth-actions.ts",
        "nextSteps": [
          "Check if redirect() is being called correctly",
          "Verify dashboard path is correct",
          "Check middleware configuration"
        ]
      },
      "testResult": {
        "passed": false,
        "error": "Could not detect redirect issue in auth-actions.ts",
        "duration": 0
      },
      "artifacts": {
        "screenshots": [],
        "logs": [],
        "diffs": []
      }
    }
  ],
  "timestamp": "2025-09-30T10-57-53.546Z"
}