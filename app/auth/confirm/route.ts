import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/services/core/supabase-client'
import { emailService } from '@/lib/email/email-service'
import { EMAIL_CONFIG } from '@/lib/email/resend-client'
import { createServerUserService } from '@/lib/services'
import { createClient } from '@supabase/supabase-js'

/**
 * üìß ROUTE UNIFI√âE - Confirmation Email & Invitations
 *
 * G√®re 3 types de confirmations:
 * 1. type=email ‚Üí Confirmation inscription (signup)
 * 2. type=invite ‚Üí Confirmation invitation (team invite)
 * 3. type=recovery ‚Üí R√©initialisation mot de passe
 *
 * Pattern: PKCE Flow avec verifyOtp()
 * R√©f√©rence: https://supabase.com/docs/guides/auth/sessions/pkce-flow
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const token_hash = searchParams.get('token_hash')
    const type = searchParams.get('type') as 'email' | 'invite' | 'recovery' | null

    console.log('üîê [AUTH-CONFIRM] Starting confirmation:', {
      type,
      has_token: !!token_hash,
      token_length: token_hash?.length || 0,
      full_url: request.url
    })

    // Validation param√®tres
    if (!token_hash || !type) {
      console.error('‚ùå [AUTH-CONFIRM] Missing parameters:', {
        token_hash: !!token_hash,
        type,
        all_params: Object.fromEntries(searchParams.entries())
      })
      return NextResponse.redirect(
        new URL('/auth/login?error=invalid_confirmation_link', request.url)
      )
    }

    // Cr√©er client Supabase server
    const supabase = await createServerSupabaseClient()

    console.log('üîß [AUTH-CONFIRM] Calling verifyOtp...')

    // ‚úÖ V√âRIFIER OTP avec Supabase (essai principal)
    let { data, error } = await supabase.auth.verifyOtp({
      token_hash,
      type: type as any, // Type casting car TypeScript peut √™tre strict
    })

    // üîÅ Fallback: certains tokens g√©n√©r√©s via admin.generateLink({ type: 'signup' })
    // peuvent n√©cessiter verifyOtp avec type='signup'.
    if ((error || !data?.user) && type === 'email') {
      console.warn('üîÅ [AUTH-CONFIRM] Primary verifyOtp failed with type=email, retrying with type=signup...')
      const retry = await supabase.auth.verifyOtp({
        token_hash,
        type: 'signup' as any,
      })
      if (!retry.error && retry.data?.user) {
        data = retry.data
        error = null as any
        console.log('‚úÖ [AUTH-CONFIRM] Fallback verifyOtp(type=signup) succeeded')
      }
    }

    if (error || !data?.user) {
      console.error('‚ùå [AUTH-CONFIRM] OTP verification failed:', {
        message: error?.message,
        name: error?.name,
        status: error?.status,
        errorDetails: error,
        hasData: !!data,
        hasUser: !!data?.user,
        attemptedType: type,
      })

      // Messages d'erreur sp√©cifiques
      const errorMessages: Record<string, string> = {
        'Token has expired or is invalid': 'expired_token',
        'Email link is invalid or has expired': 'expired_token',
        'Invalid token': 'invalid_token',
      }

      const errorCode = error?.message
        ? errorMessages[error.message] || 'confirmation_failed'
        : 'confirmation_failed'

      return NextResponse.redirect(
        new URL(`/auth/login?error=${errorCode}`, request.url)
      )
    }

    const user = data.user
    console.log('‚úÖ [AUTH-CONFIRM] OTP verified for:', user.email)

    // ‚úÖ √Ä ce stade, le trigger a d√©j√† cr√©√© le profil utilisateur !
    // (car verifyOtp() met √† jour email_confirmed_at, d√©clenchant le trigger)

    // ============================================================================
    // GESTION PAR TYPE
    // ============================================================================

    if (type === 'email') {
      // üìß CONFIRMATION SIGNUP PUBLIC
      console.log('üìß [AUTH-CONFIRM] Email confirmation (signup) for:', user.email)

      // ‚úÖ NOUVEAU PATTERN (2025-10-03): Cr√©ation directe du profil (plus de d√©pendance sur trigger DB)
      // Apr√®s analyse avec 3 agents sp√©cialis√©s, le trigger PostgreSQL est trop fragile
      // ‚Üí Cr√©ation server-side avec contr√¥le total et logs clairs

      let userRole: 'admin' | 'gestionnaire' | 'prestataire' | 'locataire' = 'gestionnaire'
      let userProfileId: string | null = null
      let teamId: string | null = null

      try {
        // V√©rifier si profil existe d√©j√† (edge case : retry ou trigger a r√©ussi)
        const userService = await createServerUserService()
        const existingProfile = await userService.getByAuthUserId(user.id)

        if (existingProfile.success && existingProfile.data) {
          // Profil d√©j√† cr√©√© (trigger a fonctionn√© ou retry)
          console.log('‚úÖ [AUTH-CONFIRM] Profile already exists:', {
            userId: existingProfile.data.id,
            role: existingProfile.data.role,
            teamId: existingProfile.data.team_id
          })
          userRole = existingProfile.data.role
          userProfileId = existingProfile.data.id
          teamId = existingProfile.data.team_id
        } else {
          // Cr√©er le profil directement (pattern recommand√© 2025)
          console.log('üî® [AUTH-CONFIRM] Creating profile server-side...')

          // Extraire les m√©tadonn√©es
          const firstName = user.raw_user_meta_data?.first_name || 'Utilisateur'
          const lastName = user.raw_user_meta_data?.last_name || ''
          const fullName = user.raw_user_meta_data?.full_name || `${firstName} ${lastName}`.trim()
          userRole = (user.raw_user_meta_data?.role || 'gestionnaire') as typeof userRole
          const phone = user.raw_user_meta_data?.phone

          // ‚ö†Ô∏è IMPORTANT: Utiliser le client ADMIN pour bypass RLS
          // Le UserService utilise le client server (avec session user) qui est bloqu√© par RLS
          // Car les policies n√©cessitent que l'utilisateur existe d√©j√† dans public.users (chicken and egg!)
          const supabaseAdmin = createClient(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.SUPABASE_SERVICE_ROLE_KEY!,
            {
              auth: {
                autoRefreshToken: false,
                persistSession: false
              }
            }
          )

          // 1. Cr√©er le profil utilisateur (team_id NULL temporairement) avec admin client
          const { data: newProfile, error: profileError } = await supabaseAdmin
            .from('users')
            .insert({
              auth_user_id: user.id,
              email: user.email!,
              name: fullName || user.email!,
              role: userRole,
              phone: phone || null,
              is_active: true,
              password_set: true,
              team_id: null, // Sera mis √† jour apr√®s cr√©ation team si gestionnaire
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .select()
            .single()

          if (profileError || !newProfile) {
            console.error('‚ùå [AUTH-CONFIRM] Failed to create profile:', profileError)
            throw new Error(`Profile creation failed: ${profileError?.message || 'Unknown error'}`)
          }

          userProfileId = newProfile.id
          console.log('‚úÖ [AUTH-CONFIRM] Profile created (admin bypass RLS):', {
            userId: userProfileId,
            role: userRole,
            email: user.email
          })

          // 2. Cr√©er √©quipe si gestionnaire (owner de sa propre √©quipe)
          if (userRole === 'gestionnaire' && userProfileId) {
            const teamName = `√âquipe de ${firstName}`

            const { data: newTeam, error: teamError } = await supabaseAdmin
              .from('teams')
              .insert({
                name: teamName,
                description: '√âquipe personnelle',
                created_by: userProfileId,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              })
              .select()
              .single()

            if (teamError || !newTeam) {
              console.warn('‚ö†Ô∏è [AUTH-CONFIRM] Team creation failed (non-blocking):', teamError)
            } else {
              teamId = newTeam.id
              console.log('‚úÖ [AUTH-CONFIRM] Team created:', {
                teamId,
                teamName,
                createdBy: userProfileId
              })

              // 3. Mettre √† jour le profil avec team_id
              const { error: updateError } = await supabaseAdmin
                .from('users')
                .update({ team_id: teamId })
                .eq('id', userProfileId)

              if (updateError) {
                console.warn('‚ö†Ô∏è [AUTH-CONFIRM] Failed to update profile with team_id (non-blocking):', updateError)
              } else {
                console.log('‚úÖ [AUTH-CONFIRM] Profile updated with team_id:', teamId)
              }
            }
          }
        }
      } catch (profileCreationError) {
        // ‚ö†Ô∏è IMPORTANT: Ne pas bloquer l'auth si cr√©ation profil √©choue
        // Le fallback JWT dans auth-service.ts g√®re ce cas
        console.error('‚ùå [AUTH-CONFIRM] Profile creation error (non-blocking):', profileCreationError)
        console.error('‚ö†Ô∏è [AUTH-CONFIRM] User can still login, profile will be created on first login via fallback')
      }

      // Envoyer email de bienvenue via Resend
      try {
        const firstName = user.raw_user_meta_data?.first_name || user.email?.split('@')[0] || 'Utilisateur'
        const dashboardUrl = `${EMAIL_CONFIG.appUrl}/dashboard/${userRole}`

        const emailResult = await emailService.sendWelcomeEmail(user.email!, {
          firstName,
          confirmationUrl: dashboardUrl,
          role: userRole,
        })

        if (emailResult.success) {
          console.log('‚úÖ [AUTH-CONFIRM] Welcome email sent:', emailResult.emailId)
        } else {
          console.warn('‚ö†Ô∏è [AUTH-CONFIRM] Welcome email failed (non-blocking):', emailResult.error)
        }
      } catch (emailError) {
        console.error('‚ùå [AUTH-CONFIRM] Welcome email error (non-blocking):', emailError)
      }

      // ‚úÖ REDIRECTION DIRECTE VERS DASHBOARD (2025-10-03)
      // L'utilisateur est d√©j√† connect√© apr√®s verifyOtp() ‚Üí pas besoin de login
      const dashboardPath = `/dashboard/${userRole}`
      console.log(`‚úÖ [AUTH-CONFIRM] User authenticated and profile created, redirecting to: ${dashboardPath}`)

      return NextResponse.redirect(
        new URL(dashboardPath, request.url)
      )
    }

    if (type === 'invite') {
      // üë• CONFIRMATION INVITATION
      console.log('üë• [AUTH-CONFIRM] Invitation confirmation for:', user.email)

      // V√©rifier si mot de passe d√©j√† d√©fini
      const skipPassword = user.raw_user_meta_data?.skip_password === 'true'

      if (skipPassword) {
        // Rediriger vers page d√©finition mot de passe
        return NextResponse.redirect(
          new URL('/auth/set-password', request.url)
        )
      } else {
        // Mot de passe d√©j√† d√©fini, rediriger vers dashboard
        const role = user.raw_user_meta_data?.role || 'gestionnaire'
        return NextResponse.redirect(
          new URL(`/${role}/dashboard?welcome=true`, request.url)
        )
      }
    }

    if (type === 'recovery') {
      // üîë R√âINITIALISATION MOT DE PASSE
      console.log('üîë [AUTH-CONFIRM] Password recovery for:', user.email)

      // Rediriger vers page mise √† jour mot de passe
      return NextResponse.redirect(
        new URL('/auth/update-password', request.url)
      )
    }

    // Type non reconnu
    console.error('‚ùå [AUTH-CONFIRM] Unknown type:', type)
    return NextResponse.redirect(
      new URL('/auth/login?error=invalid_confirmation_type', request.url)
    )

  } catch (error) {
    console.error('‚ùå [AUTH-CONFIRM] Unexpected error:', error)
    return NextResponse.redirect(
      new URL('/auth/login?error=confirmation_failed', request.url)
    )
  }
}
